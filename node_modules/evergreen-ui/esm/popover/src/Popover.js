var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Positioner } from '../../positioner';
import PopoverStateless from './PopoverStateless';

var Popover = function (_Component) {
  _inherits(Popover, _Component);

  function Popover() {
    _classCallCheck(this, Popover);

    var _this = _possibleConstructorReturn(this, (Popover.__proto__ || Object.getPrototypeOf(Popover)).call(this));

    _this.onBodyClick = function (e) {
      // Ignore clicks on the popover or button
      if (_this.targetNode === e.target) {
        return;
      }

      if (_this.popoverNode && (_this.popoverNode === e.target || _this.popoverNode.contains(e.target))) {
        return;
      }

      _this.close();
    };

    _this.onResize = function () {
      _this.close();
    };

    _this.onEsc = function (e) {
      // Esc key
      if (e.keyCode === 27) {
        _this.close();
      }
    };

    _this.getRef = function (ref) {
      _this.targetNode = ref;
    };

    _this.getTargetRect = function () {
      return _this.targetNode.getBoundingClientRect();
    };

    _this.toggle = function () {
      var isOpen = !_this.state.isOpen;

      if (isOpen) {
        _this.open();
      } else {
        _this.close();
      }

      _this.setState({ isOpen: isOpen });
    };

    _this.open = function () {
      if (_this.state.isOpen) {
        return;
      }

      _this.setState({ isOpen: true, targetRect: _this.getTargetRect() });
      document.body.addEventListener('click', _this.onBodyClick, false);
      document.body.addEventListener('keydown', _this.onEsc, false);
      window.addEventListener('resize', _this.onResize, false);

      _this.props.onOpen();
    };

    _this.close = function () {
      if (!_this.state.isOpen) {
        return;
      }

      _this.setState({ isOpen: false });
      document.body.removeEventListener('click', _this.onBodyClick, false);
      document.body.removeEventListener('keydown', _this.onEsc, false);
      window.removeEventListener('resize', _this.resize, false);

      _this.props.onClose();
    };

    _this.state = {
      isOpen: false,
      targetRect: {}
    };
    return _this;
  }

  _createClass(Popover, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (Object.prototype.hasOwnProperty.call(nextProps, 'isOpen')) {
        if (nextProps.isOpen) {
          this.setState({
            targetRect: this.getTargetRect()
          });
        }
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      document.body.removeEventListener('click', this.onBodyClick, false);
      document.body.removeEventListener('keydown', this.onEsc, false);
      window.removeEventListener('resize', this.resize, false);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          zIndex = _props.zIndex,
          isOpen = _props.isOpen,
          content = _props.content,
          display = _props.display,
          children = _props.children,
          minWidth = _props.minWidth,
          minHeight = _props.minHeight,
          statelessProps = _props.statelessProps,
          props = _objectWithoutProperties(_props, ['zIndex', 'isOpen', 'content', 'display', 'children', 'minWidth', 'minHeight', 'statelessProps']);

      var _state = this.state,
          stateIsOpen = _state.isOpen,
          targetRect = _state.targetRect;


      var open = isOpen || stateIsOpen;

      return [typeof children === 'function' ? children({
        targetRect: targetRect,
        toggle: this.toggle,
        getRef: this.getRef,
        isOpen: open,
        key: 'popover-child'
      }) : React.cloneElement(children, _extends({
        onClick: function onClick() {
          return _this2.toggle();
        },
        innerRef: function innerRef(ref) {
          _this2.getRef(ref);
        }
      }, open ? { 'data-popover-opened': true } : {}, {
        key: 'popover-child'
      })), React.createElement(
        Positioner,
        _extends({
          key: 'popover-positioner',
          targetRect: targetRect,
          zIndex: zIndex,
          isShown: open
        }, props),
        function (_ref) {
          var css = _ref.css,
              style = _ref.style,
              state = _ref.state,
              getRef = _ref.getRef;
          return React.createElement(
            PopoverStateless,
            _extends({
              innerRef: function innerRef(ref) {
                _this2.popoverNode = ref;
                getRef(ref);
              },
              'data-state': state,
              css: css,
              style: style,
              display: display,
              minWidth: minWidth,
              minHeight: minHeight
            }, statelessProps),
            typeof content === 'function' ? content({ targetRect: targetRect, close: _this2.close }) : content
          );
        }
      )];
    }
  }]);

  return Popover;
}(Component);

Popover.propTypes = _extends({}, Positioner.propTypes, {
  onOpen: PropTypes.func.isRequired,
  // Use isOpen to manually control the Popover
  isOpen: PropTypes.bool,
  onClose: PropTypes.func.isRequired,
  content: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,
  children: PropTypes.oneOfType([PropTypes.element, PropTypes.func]).isRequired,
  display: PropTypes.string,
  minWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  minHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  statelessProps: PropTypes.objectOf(PopoverStateless.propTypes)
});
Popover.defaultProps = {
  side: 'bottom',
  onOpen: function onOpen() {},
  onClose: function onClose() {},
  minWidth: 200,
  minHeight: 40
};
export default Popover;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wb3BvdmVyL3NyYy9Qb3BvdmVyLmpzIl0sIm5hbWVzIjpbIlJlYWN0IiwiQ29tcG9uZW50IiwiUHJvcFR5cGVzIiwiUG9zaXRpb25lciIsIlBvcG92ZXJTdGF0ZWxlc3MiLCJQb3BvdmVyIiwib25Cb2R5Q2xpY2siLCJ0YXJnZXROb2RlIiwiZSIsInRhcmdldCIsInBvcG92ZXJOb2RlIiwiY29udGFpbnMiLCJjbG9zZSIsIm9uUmVzaXplIiwib25Fc2MiLCJrZXlDb2RlIiwiZ2V0UmVmIiwicmVmIiwiZ2V0VGFyZ2V0UmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInRvZ2dsZSIsImlzT3BlbiIsInN0YXRlIiwib3BlbiIsInNldFN0YXRlIiwidGFyZ2V0UmVjdCIsImRvY3VtZW50IiwiYm9keSIsImFkZEV2ZW50TGlzdGVuZXIiLCJ3aW5kb3ciLCJwcm9wcyIsIm9uT3BlbiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZXNpemUiLCJvbkNsb3NlIiwibmV4dFByb3BzIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiekluZGV4IiwiY29udGVudCIsImRpc3BsYXkiLCJjaGlsZHJlbiIsIm1pbldpZHRoIiwibWluSGVpZ2h0Iiwic3RhdGVsZXNzUHJvcHMiLCJzdGF0ZUlzT3BlbiIsImtleSIsImNsb25lRWxlbWVudCIsIm9uQ2xpY2siLCJpbm5lclJlZiIsImNzcyIsInN0eWxlIiwicHJvcFR5cGVzIiwiZnVuYyIsImlzUmVxdWlyZWQiLCJib29sIiwib25lT2ZUeXBlIiwibm9kZSIsImVsZW1lbnQiLCJzdHJpbmciLCJudW1iZXIiLCJvYmplY3RPZiIsImRlZmF1bHRQcm9wcyIsInNpZGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLE9BQU9BLEtBQVAsSUFBZ0JDLFNBQWhCLFFBQWlDLE9BQWpDO0FBQ0EsT0FBT0MsU0FBUCxNQUFzQixZQUF0QjtBQUNBLFNBQVNDLFVBQVQs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Q3hELFVBQVV5RCxJQUFYLEVBQWlCekQsVUFBVXFELElBQTNCLENBQXBCLEVBQXNEQyxVO0FBQy9EYixZQUFVekMsVUFBVXdELFNBQVYsQ0FBb0IsQ0FBQ3hELFVBQVUwRCxPQUFYLEVBQW9CMUQsVUFBVXFELElBQTlCLENBQXBCLEVBQ1BDLFU7QUFDSGQsV0FBU3hDLFVBQVUyRCxNO0FBQ25CakIsWUFBVTFDLFVBQVV3RCxTQUFWLENBQW9CLENBQUN4RCxVQUFVNEQsTUFBWCxFQUFtQjVELFVBQVUyRCxNQUE3QixDQUFwQixDO0FBQ1ZoQixhQUFXM0MsVUFBVXdELFNBQVYsQ0FBb0IsQ0FBQ3hELFVBQVU0RCxNQUFYLEVBQW1CNUQsVUFBVTJELE1BQTdCLENBQXBCLEM7QUFDWGYsa0JBQWdCNUMsVUFBVTZELFFBQVYsQ0FBbUIzRCxpQkFBaUJrRCxTQUFwQzs7QUFiQ2pELE8sQ0FnQloyRCxZLEdBQWU7QUFDcEJDLFFBQU0sUUFEYztBQUVwQmxDLFVBQVEsa0JBQU0sQ0FBRSxDQUZJO0FBR3BCRyxXQUFTLG1CQUFNLENBQUUsQ0FIRztBQUlwQlUsWUFBVSxHQUpVO0FBS3BCQyxhQUFXO0FBTFMsQztlQWhCSHhDLE8iLCJmaWxlIjoiUG9wb3Zlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcydcbmltcG9ydCB7IFBvc2l0aW9uZXIgfSBmcm9tICcuLi8uLi9wb3NpdGlvbmVyJ1xuaW1wb3J0IFBvcG92ZXJTdGF0ZWxlc3MgZnJvbSAnLi9Qb3BvdmVyU3RhdGVsZXNzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3BvdmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAuLi5Qb3NpdGlvbmVyLnByb3BUeXBlcyxcbiAgICBvbk9wZW46IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgLy8gVXNlIGlzT3BlbiB0byBtYW51YWxseSBjb250cm9sIHRoZSBQb3BvdmVyXG4gICAgaXNPcGVuOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBvbkNsb3NlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIGNvbnRlbnQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ub2RlLCBQcm9wVHlwZXMuZnVuY10pLmlzUmVxdWlyZWQsXG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5lbGVtZW50LCBQcm9wVHlwZXMuZnVuY10pXG4gICAgICAuaXNSZXF1aXJlZCxcbiAgICBkaXNwbGF5OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIG1pbldpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gICAgbWluSGVpZ2h0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gICAgc3RhdGVsZXNzUHJvcHM6IFByb3BUeXBlcy5vYmplY3RPZihQb3BvdmVyU3RhdGVsZXNzLnByb3BUeXBlcylcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgc2lkZTogJ2JvdHRvbScsXG4gICAgb25PcGVuOiAoKSA9PiB7fSxcbiAgICBvbkNsb3NlOiAoKSA9PiB7fSxcbiAgICBtaW5XaWR0aDogMjAwLFxuICAgIG1pbkhlaWdodDogNDBcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaXNPcGVuOiBmYWxzZSxcbiAgICAgIHRhcmdldFJlY3Q6IHt9XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5leHRQcm9wcywgJ2lzT3BlbicpKSB7XG4gICAgICBpZiAobmV4dFByb3BzLmlzT3Blbikge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICB0YXJnZXRSZWN0OiB0aGlzLmdldFRhcmdldFJlY3QoKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQm9keUNsaWNrLCBmYWxzZSlcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uRXNjLCBmYWxzZSlcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXNpemUsIGZhbHNlKVxuICB9XG5cbiAgb25Cb2R5Q2xpY2sgPSBlID0+IHtcbiAgICAvLyBJZ25vcmUgY2xpY2tzIG9uIHRoZSBwb3BvdmVyIG9yIGJ1dHRvblxuICAgIGlmICh0aGlzLnRhcmdldE5vZGUgPT09IGUudGFyZ2V0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLnBvcG92ZXJOb2RlICYmXG4gICAgICAodGhpcy5wb3BvdmVyTm9kZSA9PT0gZS50YXJnZXQgfHwgdGhpcy5wb3BvdmVyTm9kZS5jb250YWlucyhlLnRhcmdldCkpXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmNsb3NlKClcbiAgfVxuXG4gIG9uUmVzaXplID0gKCkgPT4ge1xuICAgIHRoaXMuY2xvc2UoKVxuICB9XG5cbiAgb25Fc2MgPSBlID0+IHtcbiAgICAvLyBFc2Mga2V5XG4gICAgaWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIGdldFJlZiA9IHJlZiA9PiB7XG4gICAgdGhpcy50YXJnZXROb2RlID0gcmVmXG4gIH1cblxuICBnZXRUYXJnZXRSZWN0ID0gKCkgPT4gdGhpcy50YXJnZXROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgdG9nZ2xlID0gKCkgPT4ge1xuICAgIGNvbnN0IGlzT3BlbiA9ICF0aGlzLnN0YXRlLmlzT3BlblxuXG4gICAgaWYgKGlzT3Blbikge1xuICAgICAgdGhpcy5vcGVuKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbG9zZSgpXG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGlzT3BlbiB9KVxuICB9XG5cbiAgb3BlbiA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5zdGF0ZS5pc09wZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoeyBpc09wZW46IHRydWUsIHRhcmdldFJlY3Q6IHRoaXMuZ2V0VGFyZ2V0UmVjdCgpIH0pXG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25Cb2R5Q2xpY2ssIGZhbHNlKVxuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25Fc2MsIGZhbHNlKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLm9uUmVzaXplLCBmYWxzZSlcblxuICAgIHRoaXMucHJvcHMub25PcGVuKClcbiAgfVxuXG4gIGNsb3NlID0gKCkgPT4ge1xuICAgIGlmICghdGhpcy5zdGF0ZS5pc09wZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoeyBpc09wZW46IGZhbHNlIH0pXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25Cb2R5Q2xpY2ssIGZhbHNlKVxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25Fc2MsIGZhbHNlKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlc2l6ZSwgZmFsc2UpXG5cbiAgICB0aGlzLnByb3BzLm9uQ2xvc2UoKVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHpJbmRleCxcbiAgICAgIGlzT3BlbixcbiAgICAgIGNvbnRlbnQsXG4gICAgICBkaXNwbGF5LFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBtaW5XaWR0aCxcbiAgICAgIG1pbkhlaWdodCxcbiAgICAgIHN0YXRlbGVzc1Byb3BzLFxuICAgICAgLi4ucHJvcHNcbiAgICB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHsgaXNPcGVuOiBzdGF0ZUlzT3BlbiwgdGFyZ2V0UmVjdCB9ID0gdGhpcy5zdGF0ZVxuXG4gICAgY29uc3Qgb3BlbiA9IGlzT3BlbiB8fCBzdGF0ZUlzT3BlblxuXG4gICAgcmV0dXJuIFtcbiAgICAgIHR5cGVvZiBjaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkcmVuKHtcbiAgICAgICAgICAgIHRhcmdldFJlY3QsXG4gICAgICAgICAgICB0b2dnbGU6IHRoaXMudG9nZ2xlLFxuICAgICAgICAgICAgZ2V0UmVmOiB0aGlzLmdldFJlZixcbiAgICAgICAgICAgIGlzT3Blbjogb3BlbixcbiAgICAgICAgICAgIGtleTogJ3BvcG92ZXItY2hpbGQnXG4gICAgICAgICAgfSlcbiAgICAgICAgOiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGRyZW4sIHtcbiAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHRoaXMudG9nZ2xlKCksXG4gICAgICAgICAgICBpbm5lclJlZjogcmVmID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5nZXRSZWYocmVmKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC4uLihvcGVuID8geyAnZGF0YS1wb3BvdmVyLW9wZW5lZCc6IHRydWUgfSA6IHt9KSxcbiAgICAgICAgICAgIGtleTogJ3BvcG92ZXItY2hpbGQnXG4gICAgICAgICAgfSksXG5cbiAgICAgIDxQb3NpdGlvbmVyXG4gICAgICAgIGtleT1cInBvcG92ZXItcG9zaXRpb25lclwiXG4gICAgICAgIHRhcmdldFJlY3Q9e3RhcmdldFJlY3R9XG4gICAgICAgIHpJbmRleD17ekluZGV4fVxuICAgICAgICBpc1Nob3duPXtvcGVufVxuICAgICAgICB7Li4ucHJvcHN9XG4gICAgICA+XG4gICAgICAgIHsoeyBjc3MsIHN0eWxlLCBzdGF0ZSwgZ2V0UmVmIH0pID0+IChcbiAgICAgICAgICA8UG9wb3ZlclN0YXRlbGVzc1xuICAgICAgICAgICAgaW5uZXJSZWY9e3JlZiA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucG9wb3Zlck5vZGUgPSByZWZcbiAgICAgICAgICAgICAgZ2V0UmVmKHJlZilcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICBkYXRhLXN0YXRlPXtzdGF0ZX1cbiAgICAgICAgICAgIGNzcz17Y3NzfVxuICAgICAgICAgICAgc3R5bGU9e3N0eWxlfVxuICAgICAgICAgICAgZGlzcGxheT17ZGlzcGxheX1cbiAgICAgICAgICAgIG1pbldpZHRoPXttaW5XaWR0aH1cbiAgICAgICAgICAgIG1pbkhlaWdodD17bWluSGVpZ2h0fVxuICAgICAgICAgICAgey4uLnN0YXRlbGVzc1Byb3BzfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHt0eXBlb2YgY29udGVudCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICA/IGNvbnRlbnQoeyB0YXJnZXRSZWN0LCBjbG9zZTogdGhpcy5jbG9zZSB9KVxuICAgICAgICAgICAgICA6IGNvbnRlbnR9XG4gICAgICAgICAgPC9Qb3BvdmVyU3RhdGVsZXNzPlxuICAgICAgICApfVxuICAgICAgPC9Qb3NpdGlvbmVyPlxuICAgIF1cbiAgfVxufVxuIl19