var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import fuzzaldrin from 'fuzzaldrin-plus';
import VirtualList from 'react-tiny-virtual-list';
import { Pane } from '../../layers';
import { TableHead, SearchTableHeaderCell } from '../../table';
import OptionShapePropType from './OptionShapePropType';
import Option from './Option';

/**
 * Fuzzaldrin-plus is the default filter, but you can use your own
 * as long as they follow the following signature:
 * @param options <Array[String]> - ['label', 'label2', ...]
 * @param input <String>
 */
var fuzzyFilter = function fuzzyFilter(options, input) {
  return fuzzaldrin.filter(options, input);
};

/**
 * This is the default item renderer of options
 * you can pass custom renderers as long as they work the same as the Option
 */
var itemRenderer = function itemRenderer(props) {
  return React.createElement(Option, props);
};

var OptionsList = function (_PureComponent) {
  _inherits(OptionsList, _PureComponent);

  function OptionsList(props, context) {
    _classCallCheck(this, OptionsList);

    var _this = _possibleConstructorReturn(this, (OptionsList.__proto__ || Object.getPrototypeOf(OptionsList)).call(this, props, context));

    _this.isSelected = function (item) {
      var selected = _this.state.selected;


      return Boolean(selected.find(function (selectedItem) {
        return selectedItem === item.value;
      }));
    };

    _this.search = function (options) {
      var optionsFilter = _this.props.optionsFilter;
      var searchValue = _this.state.searchValue;


      return searchValue.trim() === '' ? options // Return if no search query
      : optionsFilter(options.map(function (item) {
        return item.labelInList || item.label;
      }), searchValue).map(function (name) {
        return options.find(function (item) {
          return item.labelInList === name || item.label === name;
        });
      });
    };

    _this.handleChange = function (searchValue) {
      _this.setState({
        searchValue: searchValue
      });
    };

    _this.handleSelect = function (item) {
      _this.props.onSelect(item);
    };

    _this.assignSearchRef = function (ref) {
      _this.searchRef = ref;
    };

    _this.state = {
      searchValue: props.defaultSearchValue,
      selected: props.selected
    };
    return _this;
  }

  _createClass(OptionsList, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      var hasFilter = this.props.hasFilter;

      if (!hasFilter) return;
      /**
       * Hacky solution for broken autoFocus
       * https://github.com/segmentio/evergreen/issues/90
       */
      window.setTimeout(function () {
        _this2.searchRef.querySelector('input').focus();
      }, 1);
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.selected !== this.state.selected) {
        this.setState({
          selected: nextProps.selected
        });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var _props = this.props,
          originalOptions = _props.options,
          close = _props.close,
          width = _props.width,
          height = _props.height,
          onSelect = _props.onSelect,
          selected = _props.selected,
          hasFilter = _props.hasFilter,
          optionSize = _props.optionSize,
          _renderItem = _props.renderItem,
          placeholder = _props.placeholder,
          optionsFilter = _props.optionsFilter,
          defaultSearchValue = _props.defaultSearchValue,
          props = _objectWithoutProperties(_props, ['options', 'close', 'width', 'height', 'onSelect', 'selected', 'hasFilter', 'optionSize', 'renderItem', 'placeholder', 'optionsFilter', 'defaultSearchValue']);

      var options = this.search(originalOptions);
      var listHeight = height - (hasFilter ? 32 : 0);

      return React.createElement(
        Pane,
        _extends({
          height: height,
          width: width,
          display: 'flex',
          flexDirection: 'column'
        }, props),
        hasFilter && React.createElement(
          TableHead,
          null,
          React.createElement(SearchTableHeaderCell, {
            onChange: this.handleChange,
            innerRef: this.assignSearchRef,
            borderRight: null,
            height: 32
          })
        ),
        React.createElement(
          Pane,
          { flex: 1 },
          React.createElement(VirtualList, {
            height: listHeight,
            width: '100%',
            itemSize: optionSize,
            itemCount: options.length,
            overscanCount: 3,
            scrollToAlignment: 'auto',
            renderItem: function renderItem(_ref) {
              var index = _ref.index,
                  style = _ref.style;

              var item = options[index];
              return _renderItem({
                key: item.value,
                label: item.label,
                style: style,
                height: optionSize,
                onSelect: function onSelect() {
                  return _this3.handleSelect(item);
                },
                isSelected: _this3.isSelected(item)
              });
            }
          })
        )
      );
    }
  }]);

  return OptionsList;
}(PureComponent);

OptionsList.propTypes = {
  options: PropTypes.arrayOf(OptionShapePropType),
  close: PropTypes.func,
  height: PropTypes.number,
  width: PropTypes.number,

  /**
   * This holds the values of the options
   */
  selected: PropTypes.arrayOf(PropTypes.string),
  onSelect: PropTypes.func,
  hasFilter: PropTypes.bool,
  optionSize: PropTypes.number,
  renderItem: PropTypes.func,
  placeholder: PropTypes.string,
  optionsFilter: PropTypes.func,
  defaultSearchValue: PropTypes.string
};
OptionsList.defaultProps = {
  options: [],
  /**
   * Including border bottom
   * For some reason passing height to TableRow doesn't work
   * TODO: fix hacky solution
   */
  optionSize: 33,
  onSelect: function onSelect() {},
  selected: [],
  renderItem: itemRenderer,
  optionsFilter: fuzzyFilter,
  placeholder: 'Filter...',
  defaultSearchValue: ''
};
export default OptionsList;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zZWxlY3QtbWVudS9zcmMvT3B0aW9uc0xpc3QuanMiXSwibmFtZXMiOlsiUmVhY3QiLCJQdXJlQ29tcG9uZW50IiwiUHJvcFR5cGVzIiwiZnV6emFsZHJpbiIsIlZpcnR1YWxMaXN0IiwiUGFuZSIsIlRhYmxlSGVhZCIsIlNlYXJjaFRhYmxlSGVhZGVyQ2VsbCIsIk9wdGlvblNoYXBlUHJvcFR5cGUiLCJPcHRpb24iLCJmdXp6eUZpbHRlciIsIm9wdGlvbnMiLCJpbnB1dCIsImZpbHRlciIsIml0ZW1SZW5kZXJlciIsInByb3BzIiwiT3B0aW9uc0xpc3QiLCJjb250ZXh0IiwiaXNTZWxlY3RlZCIsInNlbGVjdGVkIiwic3RhdGUiLCJCb29sZWFuIiwiZmluZCIsInNlbGVjdGVkSXRlbSIsIml0ZW0iLCJ2YWx1ZSIsInNlYXJjaCIsIm9wdGlvbnNGaWx0ZXIiLCJzZWFyY2hWYWx1ZSIsInRyaW0iLCJtYXAiLCJsYWJlbEluTGlzdCIsImxhYmVsIiwibmFtZSIsImhhbmRsZUNoYW5nZSIsInNldFN0YXRlIiwiaGFuZGxlU2VsZWN0Iiwib25TZWxlY3QiLCJhc3NpZ25TZWFyY2hSZWYiLCJzZWFyY2hSZWYiLCJyZWYiLCJkZWZhdWx0U2VhcmNoVmFsdWUiLCJoYXNGaWx0ZXIiLCJ3aW5kb3ciLCJzZXRUaW1lb3V0IiwicXVlcnlTZWxlY3RvciIsImZvY3VzIiwibmV4dFByb3BzIiwib3JpZ2luYWxPcHRpb25zIiwiY2xvc2UiLCJ3aWR0aCIsImhlaWdodCIsIm9wdGlvblNpemUiLCJyZW5kZXJJdGVtIiwicGxhY2Vob2xkZXIiLCJsaXN0SGVpZ2h0IiwibGVuZ3RoIiwiaW5kZXgiLCJzdHlsZSIsImtleSIsInByb3BUeXBlcyIsImFycmF5T2YiLCJmdW5jIiwibnVtYmVyIiwic3RyaW5nIiwiYm9vbCIsImRlZmF1bHRQcm9wcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsT0FBT0EsS0FBUCxJQUFnQkMsYUFBaEIsUUFBcUMs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QUFZdkMsWUFWUTtBQVdwQmEsaUJBQWVqQixXQVhLO0FBWXBCNEMsZUFBYSxXQVpPO0FBYXBCYixzQkFBb0I7QUFiQSxDO2VBcEJIekIsVyIsImZpbGUiOiJPcHRpb25zTGlzdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgZnV6emFsZHJpbiBmcm9tICdmdXp6YWxkcmluLXBsdXMnXG5pbXBvcnQgVmlydHVhbExpc3QgZnJvbSAncmVhY3QtdGlueS12aXJ0dWFsLWxpc3QnXG5pbXBvcnQgeyBQYW5lIH0gZnJvbSAnLi4vLi4vbGF5ZXJzJ1xuaW1wb3J0IHsgVGFibGVIZWFkLCBTZWFyY2hUYWJsZUhlYWRlckNlbGwgfSBmcm9tICcuLi8uLi90YWJsZSdcbmltcG9ydCBPcHRpb25TaGFwZVByb3BUeXBlIGZyb20gJy4vT3B0aW9uU2hhcGVQcm9wVHlwZSdcbmltcG9ydCBPcHRpb24gZnJvbSAnLi9PcHRpb24nXG5cbi8qKlxuICogRnV6emFsZHJpbi1wbHVzIGlzIHRoZSBkZWZhdWx0IGZpbHRlciwgYnV0IHlvdSBjYW4gdXNlIHlvdXIgb3duXG4gKiBhcyBsb25nIGFzIHRoZXkgZm9sbG93IHRoZSBmb2xsb3dpbmcgc2lnbmF0dXJlOlxuICogQHBhcmFtIG9wdGlvbnMgPEFycmF5W1N0cmluZ10+IC0gWydsYWJlbCcsICdsYWJlbDInLCAuLi5dXG4gKiBAcGFyYW0gaW5wdXQgPFN0cmluZz5cbiAqL1xuY29uc3QgZnV6enlGaWx0ZXIgPSAob3B0aW9ucywgaW5wdXQpID0+IGZ1enphbGRyaW4uZmlsdGVyKG9wdGlvbnMsIGlucHV0KVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGRlZmF1bHQgaXRlbSByZW5kZXJlciBvZiBvcHRpb25zXG4gKiB5b3UgY2FuIHBhc3MgY3VzdG9tIHJlbmRlcmVycyBhcyBsb25nIGFzIHRoZXkgd29yayB0aGUgc2FtZSBhcyB0aGUgT3B0aW9uXG4gKi9cbmNvbnN0IGl0ZW1SZW5kZXJlciA9IHByb3BzID0+IDxPcHRpb24gey4uLnByb3BzfSAvPlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcHRpb25zTGlzdCBleHRlbmRzIFB1cmVDb21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIG9wdGlvbnM6IFByb3BUeXBlcy5hcnJheU9mKE9wdGlvblNoYXBlUHJvcFR5cGUpLFxuICAgIGNsb3NlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGhvbGRzIHRoZSB2YWx1ZXMgb2YgdGhlIG9wdGlvbnNcbiAgICAgKi9cbiAgICBzZWxlY3RlZDogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZyksXG4gICAgb25TZWxlY3Q6IFByb3BUeXBlcy5mdW5jLFxuICAgIGhhc0ZpbHRlcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgb3B0aW9uU2l6ZTogUHJvcFR5cGVzLm51bWJlcixcbiAgICByZW5kZXJJdGVtOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBwbGFjZWhvbGRlcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvcHRpb25zRmlsdGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBkZWZhdWx0U2VhcmNoVmFsdWU6IFByb3BUeXBlcy5zdHJpbmdcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgb3B0aW9uczogW10sXG4gICAgLyoqXG4gICAgICogSW5jbHVkaW5nIGJvcmRlciBib3R0b21cbiAgICAgKiBGb3Igc29tZSByZWFzb24gcGFzc2luZyBoZWlnaHQgdG8gVGFibGVSb3cgZG9lc24ndCB3b3JrXG4gICAgICogVE9ETzogZml4IGhhY2t5IHNvbHV0aW9uXG4gICAgICovXG4gICAgb3B0aW9uU2l6ZTogMzMsXG4gICAgb25TZWxlY3Q6ICgpID0+IHt9LFxuICAgIHNlbGVjdGVkOiBbXSxcbiAgICByZW5kZXJJdGVtOiBpdGVtUmVuZGVyZXIsXG4gICAgb3B0aW9uc0ZpbHRlcjogZnV6enlGaWx0ZXIsXG4gICAgcGxhY2Vob2xkZXI6ICdGaWx0ZXIuLi4nLFxuICAgIGRlZmF1bHRTZWFyY2hWYWx1ZTogJydcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XG4gICAgc3VwZXIocHJvcHMsIGNvbnRleHQpXG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgc2VhcmNoVmFsdWU6IHByb3BzLmRlZmF1bHRTZWFyY2hWYWx1ZSxcbiAgICAgIHNlbGVjdGVkOiBwcm9wcy5zZWxlY3RlZFxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IHsgaGFzRmlsdGVyIH0gPSB0aGlzLnByb3BzXG4gICAgaWYgKCFoYXNGaWx0ZXIpIHJldHVyblxuICAgIC8qKlxuICAgICAqIEhhY2t5IHNvbHV0aW9uIGZvciBicm9rZW4gYXV0b0ZvY3VzXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL3NlZ21lbnRpby9ldmVyZ3JlZW4vaXNzdWVzLzkwXG4gICAgICovXG4gICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5zZWFyY2hSZWYucXVlcnlTZWxlY3RvcignaW5wdXQnKS5mb2N1cygpXG4gICAgfSwgMSlcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgaWYgKG5leHRQcm9wcy5zZWxlY3RlZCAhPT0gdGhpcy5zdGF0ZS5zZWxlY3RlZCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHNlbGVjdGVkOiBuZXh0UHJvcHMuc2VsZWN0ZWRcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaXNTZWxlY3RlZCA9IGl0ZW0gPT4ge1xuICAgIGNvbnN0IHsgc2VsZWN0ZWQgfSA9IHRoaXMuc3RhdGVcblxuICAgIHJldHVybiBCb29sZWFuKHNlbGVjdGVkLmZpbmQoc2VsZWN0ZWRJdGVtID0+IHNlbGVjdGVkSXRlbSA9PT0gaXRlbS52YWx1ZSkpXG4gIH1cblxuICBzZWFyY2ggPSBvcHRpb25zID0+IHtcbiAgICBjb25zdCB7IG9wdGlvbnNGaWx0ZXIgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCB7IHNlYXJjaFZhbHVlIH0gPSB0aGlzLnN0YXRlXG5cbiAgICByZXR1cm4gc2VhcmNoVmFsdWUudHJpbSgpID09PSAnJ1xuICAgICAgPyBvcHRpb25zIC8vIFJldHVybiBpZiBubyBzZWFyY2ggcXVlcnlcbiAgICAgIDogb3B0aW9uc0ZpbHRlcihcbiAgICAgICAgICBvcHRpb25zLm1hcChpdGVtID0+IGl0ZW0ubGFiZWxJbkxpc3QgfHwgaXRlbS5sYWJlbCksXG4gICAgICAgICAgc2VhcmNoVmFsdWVcbiAgICAgICAgKS5tYXAobmFtZSA9PlxuICAgICAgICAgIG9wdGlvbnMuZmluZChpdGVtID0+IGl0ZW0ubGFiZWxJbkxpc3QgPT09IG5hbWUgfHwgaXRlbS5sYWJlbCA9PT0gbmFtZSlcbiAgICAgICAgKVxuICB9XG5cbiAgaGFuZGxlQ2hhbmdlID0gc2VhcmNoVmFsdWUgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc2VhcmNoVmFsdWVcbiAgICB9KVxuICB9XG5cbiAgaGFuZGxlU2VsZWN0ID0gaXRlbSA9PiB7XG4gICAgdGhpcy5wcm9wcy5vblNlbGVjdChpdGVtKVxuICB9XG5cbiAgYXNzaWduU2VhcmNoUmVmID0gcmVmID0+IHtcbiAgICB0aGlzLnNlYXJjaFJlZiA9IHJlZlxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9wdGlvbnM6IG9yaWdpbmFsT3B0aW9ucyxcbiAgICAgIGNsb3NlLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBvblNlbGVjdCxcbiAgICAgIHNlbGVjdGVkLFxuICAgICAgaGFzRmlsdGVyLFxuICAgICAgb3B0aW9uU2l6ZSxcbiAgICAgIHJlbmRlckl0ZW0sXG4gICAgICBwbGFjZWhvbGRlcixcbiAgICAgIG9wdGlvbnNGaWx0ZXIsXG4gICAgICBkZWZhdWx0U2VhcmNoVmFsdWUsXG4gICAgICAuLi5wcm9wc1xuICAgIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuc2VhcmNoKG9yaWdpbmFsT3B0aW9ucylcbiAgICBjb25zdCBsaXN0SGVpZ2h0ID0gaGVpZ2h0IC0gKGhhc0ZpbHRlciA/IDMyIDogMClcblxuICAgIHJldHVybiAoXG4gICAgICA8UGFuZVxuICAgICAgICBoZWlnaHQ9e2hlaWdodH1cbiAgICAgICAgd2lkdGg9e3dpZHRofVxuICAgICAgICBkaXNwbGF5PVwiZmxleFwiXG4gICAgICAgIGZsZXhEaXJlY3Rpb249XCJjb2x1bW5cIlxuICAgICAgICB7Li4ucHJvcHN9XG4gICAgICA+XG4gICAgICAgIHtoYXNGaWx0ZXIgJiYgKFxuICAgICAgICAgIDxUYWJsZUhlYWQ+XG4gICAgICAgICAgICA8U2VhcmNoVGFibGVIZWFkZXJDZWxsXG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLmhhbmRsZUNoYW5nZX1cbiAgICAgICAgICAgICAgaW5uZXJSZWY9e3RoaXMuYXNzaWduU2VhcmNoUmVmfVxuICAgICAgICAgICAgICBib3JkZXJSaWdodD17bnVsbH1cbiAgICAgICAgICAgICAgaGVpZ2h0PXszMn1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9UYWJsZUhlYWQ+XG4gICAgICAgICl9XG4gICAgICAgIDxQYW5lIGZsZXg9ezF9PlxuICAgICAgICAgIDxWaXJ0dWFsTGlzdFxuICAgICAgICAgICAgaGVpZ2h0PXtsaXN0SGVpZ2h0fVxuICAgICAgICAgICAgd2lkdGg9XCIxMDAlXCJcbiAgICAgICAgICAgIGl0ZW1TaXplPXtvcHRpb25TaXplfVxuICAgICAgICAgICAgaXRlbUNvdW50PXtvcHRpb25zLmxlbmd0aH1cbiAgICAgICAgICAgIG92ZXJzY2FuQ291bnQ9ezN9XG4gICAgICAgICAgICBzY3JvbGxUb0FsaWdubWVudD1cImF1dG9cIlxuICAgICAgICAgICAgcmVuZGVySXRlbT17KHsgaW5kZXgsIHN0eWxlIH0pID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IG9wdGlvbnNbaW5kZXhdXG4gICAgICAgICAgICAgIHJldHVybiByZW5kZXJJdGVtKHtcbiAgICAgICAgICAgICAgICBrZXk6IGl0ZW0udmFsdWUsXG4gICAgICAgICAgICAgICAgbGFiZWw6IGl0ZW0ubGFiZWwsXG4gICAgICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBvcHRpb25TaXplLFxuICAgICAgICAgICAgICAgIG9uU2VsZWN0OiAoKSA9PiB0aGlzLmhhbmRsZVNlbGVjdChpdGVtKSxcbiAgICAgICAgICAgICAgICBpc1NlbGVjdGVkOiB0aGlzLmlzU2VsZWN0ZWQoaXRlbSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9QYW5lPlxuICAgICAgPC9QYW5lPlxuICAgIClcbiAgfVxufVxuIl19