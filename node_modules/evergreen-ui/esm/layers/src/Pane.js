var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import Box from 'ui-box';
import ElevationStyles from './styles/elevation-styles';
import BorderColors from './styles/border-colors';
import LayerAppearances from './styles/layer-appearances';

var ElevationPropType = PropTypes.oneOf(ElevationStyles.map(function (_, index) {
  return index;
}));

var StringAndBoolPropType = PropTypes.oneOfType([PropTypes.string, PropTypes.bool]);

var Pane = function (_PureComponent) {
  _inherits(Pane, _PureComponent);

  function Pane() {
    _classCallCheck(this, Pane);

    return _possibleConstructorReturn(this, (Pane.__proto__ || Object.getPrototypeOf(Pane)).apply(this, arguments));
  }

  _createClass(Pane, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          appearance = _props.appearance,
          elevation = _props.elevation,
          hoverElevation = _props.hoverElevation,
          activeElevation = _props.activeElevation,
          border = _props.border,
          borderTop = _props.borderTop,
          borderRight = _props.borderRight,
          borderBottom = _props.borderBottom,
          borderLeft = _props.borderLeft,
          _props$css = _props.css,
          css = _props$css === undefined ? {} : _props$css,
          props = _objectWithoutProperties(_props, ['appearance', 'elevation', 'hoverElevation', 'activeElevation', 'border', 'borderTop', 'borderRight', 'borderBottom', 'borderLeft', 'css']);

      var appearanceStyle = {};
      if (Object.prototype.hasOwnProperty.call(LayerAppearances, appearance)) {
        appearanceStyle = LayerAppearances[appearance];
      }

      var elevationStyle = void 0;
      if (Number.isInteger(elevation)) {
        elevationStyle = ElevationStyles[elevation];
      }

      var hoverElevationStyle = {};
      if (Number.isInteger(hoverElevation)) {
        hoverElevationStyle = {
          transitionDuration: '150ms',
          transitionProperty: 'box-shadow, transform',
          transitionTimingFunction: 'cubic-bezier(0.0, 0.0, 0.2, 1)',
          ':hover': _extends({}, css[':hover'] || {}, {
            transform: 'translateY(-2px)',
            boxShadow: ElevationStyles[hoverElevation]
          })
        };
      }

      var activeElevationStyle = {};
      if (Number.isInteger(activeElevation)) {
        activeElevationStyle = {
          ':active': _extends({}, css[':active'] || {}, {
            transform: 'translateY(-1px)',
            boxShadow: ElevationStyles[activeElevation]
          })
        };
      }

      var _map = [borderTop, borderRight, borderBottom, borderLeft].map(function (borderSideProperty) {
        if (Object.prototype.hasOwnProperty.call(BorderColors, borderSideProperty)) {
          return '1px solid ' + BorderColors[borderSideProperty];
        } else if (borderSideProperty === true) {
          // Use default, which is now muted, border color when explicitly a true boolean
          return '1px solid ' + BorderColors.muted;
        } else if (Object.prototype.hasOwnProperty.call(BorderColors, border)) {
          return '1px solid ' + BorderColors[border];
        } else if (border === true) {
          return '1px solid ' + BorderColors.muted;
        }

        return borderSideProperty;
      }),
          _map2 = _slicedToArray(_map, 4),
          _borderTop = _map2[0],
          _borderRight = _map2[1],
          _borderBottom = _map2[2],
          _borderLeft = _map2[3];

      return React.createElement(Box, _extends({
        borderTop: _borderTop,
        borderRight: _borderRight,
        borderBottom: _borderBottom,
        borderLeft: _borderLeft,
        boxShadow: elevationStyle
      }, appearanceStyle, {
        css: _extends({}, css, hoverElevationStyle, activeElevationStyle)
      }, props));
    }
  }]);

  return Pane;
}(PureComponent);

Pane.propTypes = _extends({}, Box.propTypes, {

  appearance: PropTypes.oneOf(Object.keys(LayerAppearances)),

  elevation: ElevationPropType,
  hoverElevation: ElevationPropType,
  activeElevation: ElevationPropType,

  // Enable to set a boolean for a default border
  borderTop: StringAndBoolPropType,
  borderRight: StringAndBoolPropType,
  borderBottom: StringAndBoolPropType,
  borderLeft: StringAndBoolPropType
});
export default Pane;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9sYXllcnMvc3JjL1BhbmUuanMiXSwibmFtZXMiOlsiUmVhY3QiLCJQdXJlQ29tcG9uZW50IiwiUHJvcFR5cGVzIiwiQm94IiwiRWxldmF0aW9uU3R5bGVzIiwiQm9yZGVyQ29sb3JzIiwiTGF5ZXJBcHBlYXJhbmNlcyIsIkVsZXZhdGlvblByb3BUeXBlIiwib25lT2YiLCJtYXAiLCJfIiwiaW5kZXgiLCJTdHJpbmdBbmRCb29sUHJvcFR5cGUiLCJvbmVPZlR5cGUiLCJzdHJpbmciLCJib29sIiwiUGFuZSIsInByb3BzIiwiYXBwZWFyYW5jZSIsImVsZXZhdGlvbiIsImhvdmVyRWxldmF0aW9uIiwiYWN0aXZlRWxldmF0aW9uIiwiYm9yZGVyIiwiYm9yZGVyVG9wIiwiYm9yZGVyUmlnaHQiLCJib3JkZXJCb3R0b20iLCJib3JkZXJMZWZ0IiwiY3NzIiwiYXBwZWFyYW5jZVN0eWxlIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZWxldmF0aW9uU3R5bGUiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJob3ZlckVsZXZhdGlvblN0eWxlIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwidHJhbnNpdGlvblByb3BlcnR5IiwidHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uIiwidHJhbnNmb3JtIiwiYm94U2hhZG93IiwiYWN0aXZlRWxldmF0aW9uU3R5bGUiLCJib3JkZXJTaWRlUHJvcGVydHkiLCJtdXRlZCIsIl9ib3JkZXJUb3AiLCJfYm9yZGVyUmlnaHQiLCJfYm9yZGVyQm90dG9tIiwiX2JvcmRlckxlZnQiLCJwcm9wVHlwZXMiLCJrZXlzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLE9BQU9BLEtBQVAsSUFBZ0JDLGFBQWhCLFFBQXFDLE9BQXJDO0FBQ0EsT0FBT0MsU0FBUCxNQUFzQixZQUF0QjtBQUNBLE9BQU9DLEdBQVAsTUFBZ0IsUUFBaEI7QUFDQSxPQUFPQyxlQUFQLE1BQTRCLDJCQUE1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QUFDRDs7QUFFRCxlQUFPRCxrQkFBUDtBQUNELE9BcEI4RCxDQXJEeEQ7QUFBQTtBQUFBLFVBcURBRSxVQXJEQTtBQUFBLFVBcURZQyxZQXJEWjtBQUFBLFVBcUQwQkMsYUFyRDFCO0FBQUEsVUFxRHlDQyxXQXJEekM7O0FBMkVQLGFBQ0Usb0JBQUMsR0FBRDtBQUNFLG1CQUFXSCxVQURiO0FBRUUscUJBQWFDLFlBRmY7QUFHRSxzQkFBY0MsYUFIaEI7QUFJRSxvQkFBWUMsV0FKZDtBQUtFLG1CQUFXZjtBQUxiLFNBTU1MLGVBTk47QUFPRSwwQkFDS0QsR0FETCxFQUVLUyxtQkFGTCxFQUdLTSxvQkFITDtBQVBGLFNBWU16QixLQVpOLEVBREY7QUFnQkQ7Ozs7RUE1RytCaEIsYTs7QUFBYmUsSSxDQUNaaUMsUyxnQkFDRjlDLElBQUk4QyxTOztBQUVQL0IsY0FBWWhCLFVBQVVNLEtBQVYsQ0FBZ0JxQixPQUFPcUIsSUFBUCxDQUFZNUMsZ0JBQVosQ0FBaEIsQzs7QUFFWmEsYUFBV1osaUI7QUFDWGEsa0JBQWdCYixpQjtBQUNoQmMsbUJBQWlCZCxpQjs7QUFFakI7QUFDQWdCLGFBQVdYLHFCO0FBQ1hZLGVBQWFaLHFCO0FBQ2JhLGdCQUFjYixxQjtBQUNkYyxjQUFZZDs7ZUFkS0ksSSIsImZpbGUiOiJQYW5lLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcydcbmltcG9ydCBCb3ggZnJvbSAndWktYm94J1xuaW1wb3J0IEVsZXZhdGlvblN0eWxlcyBmcm9tICcuL3N0eWxlcy9lbGV2YXRpb24tc3R5bGVzJ1xuaW1wb3J0IEJvcmRlckNvbG9ycyBmcm9tICcuL3N0eWxlcy9ib3JkZXItY29sb3JzJ1xuaW1wb3J0IExheWVyQXBwZWFyYW5jZXMgZnJvbSAnLi9zdHlsZXMvbGF5ZXItYXBwZWFyYW5jZXMnXG5cbmNvbnN0IEVsZXZhdGlvblByb3BUeXBlID0gUHJvcFR5cGVzLm9uZU9mKFxuICBFbGV2YXRpb25TdHlsZXMubWFwKChfLCBpbmRleCkgPT4gaW5kZXgpXG4pXG5cbmNvbnN0IFN0cmluZ0FuZEJvb2xQcm9wVHlwZSA9IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICBQcm9wVHlwZXMuc3RyaW5nLFxuICBQcm9wVHlwZXMuYm9vbFxuXSlcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFuZSBleHRlbmRzIFB1cmVDb21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIC4uLkJveC5wcm9wVHlwZXMsXG5cbiAgICBhcHBlYXJhbmNlOiBQcm9wVHlwZXMub25lT2YoT2JqZWN0LmtleXMoTGF5ZXJBcHBlYXJhbmNlcykpLFxuXG4gICAgZWxldmF0aW9uOiBFbGV2YXRpb25Qcm9wVHlwZSxcbiAgICBob3ZlckVsZXZhdGlvbjogRWxldmF0aW9uUHJvcFR5cGUsXG4gICAgYWN0aXZlRWxldmF0aW9uOiBFbGV2YXRpb25Qcm9wVHlwZSxcblxuICAgIC8vIEVuYWJsZSB0byBzZXQgYSBib29sZWFuIGZvciBhIGRlZmF1bHQgYm9yZGVyXG4gICAgYm9yZGVyVG9wOiBTdHJpbmdBbmRCb29sUHJvcFR5cGUsXG4gICAgYm9yZGVyUmlnaHQ6IFN0cmluZ0FuZEJvb2xQcm9wVHlwZSxcbiAgICBib3JkZXJCb3R0b206IFN0cmluZ0FuZEJvb2xQcm9wVHlwZSxcbiAgICBib3JkZXJMZWZ0OiBTdHJpbmdBbmRCb29sUHJvcFR5cGVcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBhcHBlYXJhbmNlLFxuXG4gICAgICBlbGV2YXRpb24sXG4gICAgICBob3ZlckVsZXZhdGlvbixcbiAgICAgIGFjdGl2ZUVsZXZhdGlvbixcblxuICAgICAgYm9yZGVyLFxuICAgICAgYm9yZGVyVG9wLFxuICAgICAgYm9yZGVyUmlnaHQsXG4gICAgICBib3JkZXJCb3R0b20sXG4gICAgICBib3JkZXJMZWZ0LFxuXG4gICAgICBjc3MgPSB7fSxcbiAgICAgIC4uLnByb3BzXG4gICAgfSA9IHRoaXMucHJvcHNcblxuICAgIGxldCBhcHBlYXJhbmNlU3R5bGUgPSB7fVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoTGF5ZXJBcHBlYXJhbmNlcywgYXBwZWFyYW5jZSkpIHtcbiAgICAgIGFwcGVhcmFuY2VTdHlsZSA9IExheWVyQXBwZWFyYW5jZXNbYXBwZWFyYW5jZV1cbiAgICB9XG5cbiAgICBsZXQgZWxldmF0aW9uU3R5bGVcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihlbGV2YXRpb24pKSB7XG4gICAgICBlbGV2YXRpb25TdHlsZSA9IEVsZXZhdGlvblN0eWxlc1tlbGV2YXRpb25dXG4gICAgfVxuXG4gICAgbGV0IGhvdmVyRWxldmF0aW9uU3R5bGUgPSB7fVxuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGhvdmVyRWxldmF0aW9uKSkge1xuICAgICAgaG92ZXJFbGV2YXRpb25TdHlsZSA9IHtcbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiAnMTUwbXMnLFxuICAgICAgICB0cmFuc2l0aW9uUHJvcGVydHk6ICdib3gtc2hhZG93LCB0cmFuc2Zvcm0nLFxuICAgICAgICB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGBjdWJpYy1iZXppZXIoMC4wLCAwLjAsIDAuMiwgMSlgLFxuICAgICAgICAnOmhvdmVyJzoge1xuICAgICAgICAgIC4uLihjc3NbJzpob3ZlciddIHx8IHt9KSxcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKC0ycHgpJyxcbiAgICAgICAgICBib3hTaGFkb3c6IEVsZXZhdGlvblN0eWxlc1tob3ZlckVsZXZhdGlvbl1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBhY3RpdmVFbGV2YXRpb25TdHlsZSA9IHt9XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoYWN0aXZlRWxldmF0aW9uKSkge1xuICAgICAgYWN0aXZlRWxldmF0aW9uU3R5bGUgPSB7XG4gICAgICAgICc6YWN0aXZlJzoge1xuICAgICAgICAgIC4uLihjc3NbJzphY3RpdmUnXSB8fCB7fSksXG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgtMXB4KScsXG4gICAgICAgICAgYm94U2hhZG93OiBFbGV2YXRpb25TdHlsZXNbYWN0aXZlRWxldmF0aW9uXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgW19ib3JkZXJUb3AsIF9ib3JkZXJSaWdodCwgX2JvcmRlckJvdHRvbSwgX2JvcmRlckxlZnRdID0gW1xuICAgICAgYm9yZGVyVG9wLFxuICAgICAgYm9yZGVyUmlnaHQsXG4gICAgICBib3JkZXJCb3R0b20sXG4gICAgICBib3JkZXJMZWZ0XG4gICAgXS5tYXAoYm9yZGVyU2lkZVByb3BlcnR5ID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKEJvcmRlckNvbG9ycywgYm9yZGVyU2lkZVByb3BlcnR5KVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBgMXB4IHNvbGlkICR7Qm9yZGVyQ29sb3JzW2JvcmRlclNpZGVQcm9wZXJ0eV19YFxuICAgICAgfSBlbHNlIGlmIChib3JkZXJTaWRlUHJvcGVydHkgPT09IHRydWUpIHtcbiAgICAgICAgLy8gVXNlIGRlZmF1bHQsIHdoaWNoIGlzIG5vdyBtdXRlZCwgYm9yZGVyIGNvbG9yIHdoZW4gZXhwbGljaXRseSBhIHRydWUgYm9vbGVhblxuICAgICAgICByZXR1cm4gYDFweCBzb2xpZCAke0JvcmRlckNvbG9ycy5tdXRlZH1gXG4gICAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChCb3JkZXJDb2xvcnMsIGJvcmRlcikpIHtcbiAgICAgICAgcmV0dXJuIGAxcHggc29saWQgJHtCb3JkZXJDb2xvcnNbYm9yZGVyXX1gXG4gICAgICB9IGVsc2UgaWYgKGJvcmRlciA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gYDFweCBzb2xpZCAke0JvcmRlckNvbG9ycy5tdXRlZH1gXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBib3JkZXJTaWRlUHJvcGVydHlcbiAgICB9KVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxCb3hcbiAgICAgICAgYm9yZGVyVG9wPXtfYm9yZGVyVG9wfVxuICAgICAgICBib3JkZXJSaWdodD17X2JvcmRlclJpZ2h0fVxuICAgICAgICBib3JkZXJCb3R0b209e19ib3JkZXJCb3R0b219XG4gICAgICAgIGJvcmRlckxlZnQ9e19ib3JkZXJMZWZ0fVxuICAgICAgICBib3hTaGFkb3c9e2VsZXZhdGlvblN0eWxlfVxuICAgICAgICB7Li4uYXBwZWFyYW5jZVN0eWxlfVxuICAgICAgICBjc3M9e3tcbiAgICAgICAgICAuLi5jc3MsXG4gICAgICAgICAgLi4uaG92ZXJFbGV2YXRpb25TdHlsZSxcbiAgICAgICAgICAuLi5hY3RpdmVFbGV2YXRpb25TdHlsZVxuICAgICAgICB9fVxuICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAvPlxuICAgIClcbiAgfVxufVxuIl19