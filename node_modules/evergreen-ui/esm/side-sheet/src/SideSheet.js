var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React from 'react';
import PropTypes from 'prop-types';
import { css } from 'ui-box';
import { Pane } from '../../layers';
import { Overlay } from '../../overlay';
import SheetClose from './SheetClose';

var paneProps = {
  height: '100vh',
  position: 'absolute',
  right: 0
};

var animationEasing = {
  deceleration: 'cubic-bezier(0.0, 0.0, 0.2, 1)',
  acceleration: 'cubic-bezier(0.4, 0.0, 1, 1)'
};

var ANIMATION_DURATION = 240;

var slideInAnimation = css.keyframes('slideInAnimation', {
  from: {
    transform: 'translateX(100%)'
  },
  to: {
    transform: 'translateX(0)'
  }
});

var slideOutAnimation = css.keyframes('slideOutAnimation', {
  from: {
    transform: 'translateX(0)'
  },
  to: {
    transform: 'translateX(100%)'
  }
});

var animationStyles = {
  transform: 'translateX(100%)',
  '&[data-state="entering"], &[data-state="entered"]': {
    animation: slideInAnimation + ' ' + ANIMATION_DURATION + 'ms ' + animationEasing.deceleration + ' both'
  },
  '&[data-state="exiting"]': {
    animation: slideOutAnimation + ' ' + ANIMATION_DURATION + 'ms ' + animationEasing.acceleration + ' both'
  }
};

var SideSheet = function (_React$Component) {
  _inherits(SideSheet, _React$Component);

  function SideSheet() {
    _classCallCheck(this, SideSheet);

    return _possibleConstructorReturn(this, (SideSheet.__proto__ || Object.getPrototypeOf(SideSheet)).apply(this, arguments));
  }

  _createClass(SideSheet, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          children = _props.children,
          width = _props.width,
          containerProps = _props.containerProps,
          props = _objectWithoutProperties(_props, ['children', 'width', 'containerProps']);

      return React.createElement(
        Overlay,
        props,
        function (_ref) {
          var state = _ref.state,
              close = _ref.close;
          return React.createElement(
            Pane,
            _extends({
              width: width
            }, paneProps, {
              css: animationStyles,
              'data-state': state
            }),
            React.createElement(SheetClose, { 'data-state': state, isClosing: false, onClick: close }),
            React.createElement(
              Pane,
              _extends({
                elevation: 4,
                backgroundColor: 'white',
                overflowY: 'auto',
                'data-state': state,
                width: width
              }, paneProps, containerProps),
              typeof children === 'function' ? children({ state: state, close: close }) : children
            )
          );
        }
      );
    }
  }]);

  return SideSheet;
}(React.Component);

SideSheet.propTypes = _extends({}, Overlay.propTypes, {

  /**
   * Width of the SideSheet.
   */
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /**
   * Properties to pass through the SideSheet container Pane.
   */
  containerProps: PropTypes.object
});
SideSheet.defaultProps = {
  width: 620
};


export default SideSheet;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zaWRlLXNoZWV0L3NyYy9TaWRlU2hlZXQuanMiXSwibmFtZXMiOlsiUmVhY3QiLCJQcm9wVHlwZXMiLCJjc3MiLCJQYW5lIiwiT3ZlcmxheSIsIlNoZWV0Q2xvc2UiLCJwYW5lUHJvcHMiLCJoZWlnaHQiLCJwb3NpdGlvbiIsInJpZ2h0IiwiYW5pbWF0aW9uRWFzaW5nIiwiZGVjZWxlcmF0aW9uIiwiYWNjZWxlcmF0aW9uIiwiQU5JTUFUSU9OX0RVUkFUSU9OIiwic2xpZGVJbkFuaW1hdGlvbiIsImtleWZyYW1lcyIsImZyb20iLCJ0cmFuc2Zvcm0iLCJ0byIsInNsaWRlT3V0QW5pbWF0aW9uIiwiYW5pbWF0aW9uU3R5bGVzIiwiYW5pbWF0aW9uIiwiU2lkZVNoZWV0IiwicHJvcHMiLCJjaGlsZHJlbiIsIndpZHRoIiwiY29udGFpbmVyUHJvcHMiLCJzdGF0ZSIsImNsb3NlIiwiQ29tcG9uZW50IiwicHJvcFR5cGVzIiwib25lT2ZUeXBlIiwic3RyaW5nIiwibnVtYmVyIiwib2JqZWN0IiwiZGVmYXVsdFByb3BzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxPQUFPQSxLQUFQLE1BQWtCLE9BQWxCO0FBQ0EsT0FBT0MsU0FBUCxNQUFzQixZQUF0QjtBQUNBLFNBQVNDLEdBQVQsUUFBb0IsUUFBcEI7QUFDQSxTQUFTQyxJQUFULFFBQXFCLGNBQXJCO0FBQ0EsU0FBU0MsT0FBVCxRQUF3QixlQUF4QjtBQUNBLE9BQU9DLFVBQVAsTUFBdUIsY0FBdkI7O0FBRUEsSUFBTUMsWUFBWTtBQUNoQkMsVUFBUSxPQURRO0FBRWhCQyxZQUFVLFVBRk07QUFHaEJDLFNBQU87QUFIUyxDQUFsQjs7QUFNQSxJQUFNQyxrQkFBa0I7QUFDdEJDLGdEQURzQjtBQUV0QkM7QUFGc0IsQ0FBeEI7O0FBS0EsSUFBTUMscUJBQXFCLEdBQTNCOztBQUVBLElBQU1DLG1CQUFtQlosSUFBSWEsU0FBSixDQUFjLGtCQUFkLEVBQWtDO0FBQ3pEQyxRQUFNO0FBQ0pDO0FBREksR0FEbUQ7QUFJekRDLE1BQUk7QUFDRkQ7QUFERTtBQUpxRCxDQUFsQyxDQUF6Qjs7QUFTQSxJQUFNRSxvQkFBb0JqQixJQUFJYSxTQUFKLENBQWMsbUJBQWQsRUFBbUM7QUFDM0RDLFFBQU07QUFDSkM7QUFESSxHQURxRDtBQUkzREMsTUFBSTtBQUNGRDtBQURFO0FBSnVELENBQW5DLENBQTFCOztBQVNBLElBQU1HLGtCQUFrQjtBQUN0QkgsK0JBRHNCO0FBRXRCLHVEQUFxRDtBQUNuREksZUFBY1AsZ0JBQWQsU0FBa0NELGtCQUFsQyxXQUNFSCxnQkFBZ0JDLFlBRGxCO0FBRG1ELEdBRi9CO0FBT3RCLDZCQUEyQjtBQUN6QlUsZUFBY0YsaUJBQWQsU0FBbUNOLGtCQUFuQyxXQUNFSCxnQkFBZ0JFLFlBRGxCO0FBRHlCO0FBUEwsQ0FBeEI7O0lBY01VLFM7Ozs7Ozs7Ozs7OzZCQXNCSztBQUFBLG1CQUMrQyxLQUFLQyxLQURwRDtBQUFBLFVBQ0NDLFFBREQsVUFDQ0EsUUFERDtBQUFBLFVBQ1dDLEtBRFgsVUFDV0EsS0FEWDtBQUFBLFVBQ2tCQyxjQURsQixVQUNrQkEsY0FEbEI7QUFBQSxVQUNxQ0gsS0FEckM7O0FBR1AsYUFDRTtBQUFDLGVBQUQ7QUFBYUEsYUFBYjtBQUNHO0FBQUEsY0FBR0ksS0FBSCxRQUFHQSxLQUFIO0FBQUEsY0FBVUMsS0FBVixRQUFVQSxLQUFWO0FBQUEsaUJBQ0M7QUFBQyxnQkFBRDtBQUFBO0FBQ0UscUJBQU9IO0FBRFQsZUFFTW5CLFNBRk47QUFHRSxtQkFBS2MsZUFIUDtBQUlFLDRCQUFZTztBQUpkO0FBTUUsZ0NBQUMsVUFBRCxJQUFZLGNBQVlBLEtBQXhCLEVBQStCLFdBQVcsS0FBMUMsRUFBaUQsU0FBU0MsS0FBMUQsR0FORjtBQU9FO0FBQUMsa0JBQUQ7QUFBQTtBQUNFLDJCQUFXLENBRGI7QUFFRSxpQ0FBZ0IsT0FGbEI7QUFHRSwyQkFBVSxNQUhaO0FBSUUsOEJBQVlELEtBSmQ7QUFLRSx1QkFBT0Y7QUFMVCxpQkFNTW5CLFNBTk4sRUFPTW9CLGNBUE47QUFTRyxxQkFBT0YsUUFBUCxLQUFvQixVQUFwQixHQUNHQSxTQUFTLEVBQUVHLFlBQUYsRUFBU0MsWUFBVCxFQUFULENBREgsR0FFR0o7QUFYTjtBQVBGLFdBREQ7QUFBQTtBQURILE9BREY7QUEyQkQ7Ozs7RUFwRHFCeEIsTUFBTTZCLFM7O0FBQXhCUCxTLENBQ0dRLFMsZ0JBSUYxQixRQUFRMEIsUzs7QUFFWDs7O0FBR0FMLFNBQU94QixVQUFVOEIsU0FBVixDQUFvQixDQUFDOUIsVUFBVStCLE1BQVgsRUFBbUIvQixVQUFVZ0MsTUFBN0IsQ0FBcEIsQzs7QUFFUDs7O0FBR0FQLGtCQUFnQnpCLFVBQVVpQzs7QUFmeEJaLFMsQ0FrQkdhLFksR0FBZTtBQUNwQlYsU0FBTztBQURhLEM7OztBQXFDeEIsZUFBZUgsU0FBZiIsImZpbGUiOiJTaWRlU2hlZXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgeyBjc3MgfSBmcm9tICd1aS1ib3gnXG5pbXBvcnQgeyBQYW5lIH0gZnJvbSAnLi4vLi4vbGF5ZXJzJ1xuaW1wb3J0IHsgT3ZlcmxheSB9IGZyb20gJy4uLy4uL292ZXJsYXknXG5pbXBvcnQgU2hlZXRDbG9zZSBmcm9tICcuL1NoZWV0Q2xvc2UnXG5cbmNvbnN0IHBhbmVQcm9wcyA9IHtcbiAgaGVpZ2h0OiAnMTAwdmgnLFxuICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgcmlnaHQ6IDBcbn1cblxuY29uc3QgYW5pbWF0aW9uRWFzaW5nID0ge1xuICBkZWNlbGVyYXRpb246IGBjdWJpYy1iZXppZXIoMC4wLCAwLjAsIDAuMiwgMSlgLFxuICBhY2NlbGVyYXRpb246IGBjdWJpYy1iZXppZXIoMC40LCAwLjAsIDEsIDEpYFxufVxuXG5jb25zdCBBTklNQVRJT05fRFVSQVRJT04gPSAyNDBcblxuY29uc3Qgc2xpZGVJbkFuaW1hdGlvbiA9IGNzcy5rZXlmcmFtZXMoJ3NsaWRlSW5BbmltYXRpb24nLCB7XG4gIGZyb206IHtcbiAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKDEwMCUpYFxuICB9LFxuICB0bzoge1xuICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoMClgXG4gIH1cbn0pXG5cbmNvbnN0IHNsaWRlT3V0QW5pbWF0aW9uID0gY3NzLmtleWZyYW1lcygnc2xpZGVPdXRBbmltYXRpb24nLCB7XG4gIGZyb206IHtcbiAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKDApYFxuICB9LFxuICB0bzoge1xuICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoMTAwJSlgXG4gIH1cbn0pXG5cbmNvbnN0IGFuaW1hdGlvblN0eWxlcyA9IHtcbiAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgxMDAlKWAsXG4gICcmW2RhdGEtc3RhdGU9XCJlbnRlcmluZ1wiXSwgJltkYXRhLXN0YXRlPVwiZW50ZXJlZFwiXSc6IHtcbiAgICBhbmltYXRpb246IGAke3NsaWRlSW5BbmltYXRpb259ICR7QU5JTUFUSU9OX0RVUkFUSU9OfW1zICR7XG4gICAgICBhbmltYXRpb25FYXNpbmcuZGVjZWxlcmF0aW9uXG4gICAgfSBib3RoYFxuICB9LFxuICAnJltkYXRhLXN0YXRlPVwiZXhpdGluZ1wiXSc6IHtcbiAgICBhbmltYXRpb246IGAke3NsaWRlT3V0QW5pbWF0aW9ufSAke0FOSU1BVElPTl9EVVJBVElPTn1tcyAke1xuICAgICAgYW5pbWF0aW9uRWFzaW5nLmFjY2VsZXJhdGlvblxuICAgIH0gYm90aGBcbiAgfVxufVxuXG5jbGFzcyBTaWRlU2hlZXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIC8qKlxuICAgICAqIENvbXBvc2VzIHRoZSBPdmVybGF5IGNvbXBvbmVudHMgYXMgdGhlIGJhc2UuXG4gICAgICovXG4gICAgLi4uT3ZlcmxheS5wcm9wVHlwZXMsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiB0aGUgU2lkZVNoZWV0LlxuICAgICAqL1xuICAgIHdpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyXSksXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIHRvIHBhc3MgdGhyb3VnaCB0aGUgU2lkZVNoZWV0IGNvbnRhaW5lciBQYW5lLlxuICAgICAqL1xuICAgIGNvbnRhaW5lclByb3BzOiBQcm9wVHlwZXMub2JqZWN0XG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIHdpZHRoOiA2MjBcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGNoaWxkcmVuLCB3aWR0aCwgY29udGFpbmVyUHJvcHMsIC4uLnByb3BzIH0gPSB0aGlzLnByb3BzXG5cbiAgICByZXR1cm4gKFxuICAgICAgPE92ZXJsYXkgey4uLnByb3BzfT5cbiAgICAgICAgeyh7IHN0YXRlLCBjbG9zZSB9KSA9PiAoXG4gICAgICAgICAgPFBhbmVcbiAgICAgICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgICAgIHsuLi5wYW5lUHJvcHN9XG4gICAgICAgICAgICBjc3M9e2FuaW1hdGlvblN0eWxlc31cbiAgICAgICAgICAgIGRhdGEtc3RhdGU9e3N0YXRlfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxTaGVldENsb3NlIGRhdGEtc3RhdGU9e3N0YXRlfSBpc0Nsb3Npbmc9e2ZhbHNlfSBvbkNsaWNrPXtjbG9zZX0gLz5cbiAgICAgICAgICAgIDxQYW5lXG4gICAgICAgICAgICAgIGVsZXZhdGlvbj17NH1cbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yPVwid2hpdGVcIlxuICAgICAgICAgICAgICBvdmVyZmxvd1k9XCJhdXRvXCJcbiAgICAgICAgICAgICAgZGF0YS1zdGF0ZT17c3RhdGV9XG4gICAgICAgICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgICAgICAgey4uLnBhbmVQcm9wc31cbiAgICAgICAgICAgICAgey4uLmNvbnRhaW5lclByb3BzfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7dHlwZW9mIGNoaWxkcmVuID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgPyBjaGlsZHJlbih7IHN0YXRlLCBjbG9zZSB9KVxuICAgICAgICAgICAgICAgIDogY2hpbGRyZW59XG4gICAgICAgICAgICA8L1BhbmU+XG4gICAgICAgICAgPC9QYW5lPlxuICAgICAgICApfVxuICAgICAgPC9PdmVybGF5PlxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTaWRlU2hlZXRcbiJdfQ==