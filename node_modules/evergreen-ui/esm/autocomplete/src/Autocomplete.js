var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import fuzzaldrin from 'fuzzaldrin-plus';
import Downshift from 'downshift';
import VirtualList from 'react-tiny-virtual-list';
import { Popover } from '../../popover';
import { Text } from '../../typography';
import { Pane } from '../../layers';
import AutocompleteItem from './AutocompleteItem';

var fuzzyFilter = function fuzzyFilter(items, input) {
  return fuzzaldrin.filter(items, input);
};

var autocompleteItemRenderer = function autocompleteItemRenderer(props) {
  return React.createElement(AutocompleteItem, props);
};

// https://github.com/paypal/downshift/issues/164

var Autocomplete = function (_PureComponent) {
  _inherits(Autocomplete, _PureComponent);

  function Autocomplete() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Autocomplete);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Autocomplete.__proto__ || Object.getPrototypeOf(Autocomplete)).call.apply(_ref, [this].concat(args))), _this), _this.renderResults = function (_ref2) {
      var width = _ref2.width,
          inputValue = _ref2.inputValue,
          highlightedIndex = _ref2.highlightedIndex,
          selectItemAtIndex = _ref2.selectItemAtIndex,
          selectedItem = _ref2.selectedItem,
          getItemProps = _ref2.getItemProps;
      var _this$props = _this.props,
          title = _this$props.title,
          itemSize = _this$props.itemSize,
          itemsFilter = _this$props.itemsFilter,
          originalItems = _this$props.items,
          itemToString = _this$props.itemToString,
          _renderItem = _this$props.renderItem,
          popoverMaxHeight = _this$props.popoverMaxHeight,
          isFilterDisabled = _this$props.isFilterDisabled;


      var items = isFilterDisabled || inputValue.trim() === '' ? originalItems : itemsFilter(originalItems, inputValue);

      if (items.length === 0) return null;

      return React.createElement(
        Pane,
        { width: width },
        title && React.createElement(
          Pane,
          { padding: 8, borderBottom: 'extraMuted' },
          React.createElement(
            Text,
            { size: 200, color: 'muted', isUppercase: true },
            title
          )
        ),
        items.length > 0 && React.createElement(VirtualList, {
          width: '100%',
          height: Math.min(items.length * itemSize, popoverMaxHeight),
          itemSize: itemSize,
          itemCount: items.length,
          scrollToIndex: highlightedIndex || 0,
          overscanCount: 3,
          scrollToAlignment: 'auto',
          renderItem: function renderItem(_ref3) {
            var index = _ref3.index,
                style = _ref3.style;

            var item = items[index];
            var itemString = itemToString(item);
            return _renderItem(getItemProps({
              item: item,
              key: itemString,
              index: index,
              style: style,
              children: itemString,
              onMouseUp: function onMouseUp() {
                selectItemAtIndex(index);
              },
              isSelected: selectedItem === item,
              isHighlighted: highlightedIndex === index
            }));
          }
        })
      );
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Autocomplete, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          children = _props.children,
          itemSize = _props.itemSize,
          renderItem = _props.renderItem,
          itemsFilter = _props.itemsFilter,
          popoverMaxHeight = _props.popoverMaxHeight,
          useSmartPositioning = _props.useSmartPositioning,
          popoverMinWidth = _props.popoverMinWidth,
          props = _objectWithoutProperties(_props, ['children', 'itemSize', 'renderItem', 'itemsFilter', 'popoverMaxHeight', 'useSmartPositioning', 'popoverMinWidth']);

      return React.createElement(
        Downshift,
        props,
        function (_ref4) {
          var isOpen = _ref4.isOpen,
              inputValue = _ref4.inputValue,
              getItemProps = _ref4.getItemProps,
              selectedItem = _ref4.selectedItem,
              highlightedIndex = _ref4.highlightedIndex,
              selectItemAtIndex = _ref4.selectItemAtIndex,
              restDownshiftProps = _objectWithoutProperties(_ref4, ['isOpen', 'inputValue', 'getItemProps', 'selectedItem', 'highlightedIndex', 'selectItemAtIndex']);

          return React.createElement(
            'div',
            null,
            React.createElement(
              Popover,
              {
                isOpen: isOpen,
                minWidth: popoverMinWidth,
                content: function content(_ref5) {
                  var targetRect = _ref5.targetRect;
                  return _this2.renderResults({
                    width: Math.max(targetRect.width, popoverMinWidth),
                    inputValue: inputValue,
                    getItemProps: getItemProps,
                    selectedItem: selectedItem,
                    highlightedIndex: highlightedIndex,
                    selectItemAtIndex: selectItemAtIndex
                  });
                },
                minHeight: 0,
                animationDuration: 0,
                useSmartPositioning: useSmartPositioning
              },
              function (_ref6) {
                var isOpenPopover = _ref6.isOpen,
                    toggle = _ref6.toggle,
                    getRef = _ref6.getRef,
                    key = _ref6.key;
                return children(_extends({
                  key: key,
                  isOpen: isOpenPopover,
                  toggle: toggle,
                  getRef: getRef,
                  inputValue: inputValue,
                  selectedItem: selectedItem,
                  highlightedIndex: highlightedIndex,
                  selectItemAtIndex: selectItemAtIndex
                }, restDownshiftProps));
              }
            )
          );
        }
      );
    }
  }]);

  return Autocomplete;
}(PureComponent);

Autocomplete.propTypes = _extends({
  title: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),
  items: PropTypes.array.isRequired,
  selectedItem: PropTypes.any,
  defaultSelectedItem: PropTypes.any,
  itemToString: PropTypes.func.isRequired,
  children: PropTypes.func.isRequired,
  itemSize: PropTypes.number,
  renderItem: PropTypes.func,
  itemsFilter: PropTypes.func,
  isFilterDisabled: PropTypes.bool,
  popoverMinWidth: PropTypes.number,
  popoverMaxHeight: PropTypes.number,
  useSmartPositioning: PropTypes.bool
}, Downshift.propTypes);
Autocomplete.defaultProps = {
  itemToString: function itemToString(i) {
    return i ? String(i) : '';
  },
  itemSize: 32,
  itemsFilter: fuzzyFilter,
  isFilterDisabled: false,
  popoverMinWidth: 200,
  popoverMaxHeight: 240,
  useSmartPositioning: false,
  renderItem: autocompleteItemRenderer
};
export default Autocomplete;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9hdXRvY29tcGxldGUvc3JjL0F1dG9jb21wbGV0ZS5qcyJdLCJuYW1lcyI6WyJSZWFjdCIsIlB1cmVDb21wb25lbnQiLCJQcm9wVHlwZXMiLCJmdXp6YWxkcmluIiwiRG93bnNoaWZ0IiwiVmlydHVhbExpc3QiLCJQb3BvdmVyIiwiVGV4dCIsIlBhbmUiLCJBdXRvY29tcGxldGVJdGVtIiwiZnV6enlGaWx0ZXIiLCJpdGVtcyIsImlucHV0IiwiZmlsdGVyIiwiYXV0b2NvbXBsZXRlSXRlbVJlbmRlcmVyIiwicHJvcHMiLCJBdXRvY29tcGxldGUiLCJyZW5kZXJSZXN1bHRzIiwid2lkdGgiLCJpbnB1dFZhbHVlIiwiaGlnaGxpZ2h0ZWRJbmRleCIsInNlbGVjdEl0ZW1BdEluZGV4Iiwic2VsZWN0ZWRJdGVtIiwiZ2V0SXRlbVByb3BzIiwidGl0bGUiLCJpdGVtU2l6ZSIsIml0ZW1zRmlsdGVyIiwib3JpZ2luYWxJdGVtcyIsIml0ZW1Ub1N0cmluZyIsInJlbmRlckl0ZW0iLCJwb3BvdmVyTWF4SGVpZ2h0IiwiaXNGaWx0ZXJEaXNhYmxlZCIsInRyaW0iLCJsZW5ndGgiLCJNYXRoIiwibWluIiwiaW5kZXgiLCJzdHlsZSIsIml0ZW0iLCJpdGVtU3RyaW5nIiwia2V5IiwiY2hpbGRyZW4iLCJvbk1vdXNlVXAiLCJpc1NlbGVjdGVkIiwiaXNIaWdobGlnaHRlZCIsInVzZVNtYXJ0UG9zaXRpb25pbmciLCJwb3BvdmVyTWluV2lkdGgiLCJpc09wZW4iLCJyZXN0RG93bnNoaWZ0UHJvcHMiLCJ0YXJnZXRSZWN0IiwibWF4IiwiaXNPcGVuUG9wb3ZlciIsInRvZ2dsZSIsImdldFJlZiIsInByb3BUeXBlcyIsIm9uZU9mVHlwZSIsInN0cmluZyIsIm5vZGUiLCJhcnJheSIsImlzUmVxdWlyZWQiLCJhbnkiLCJkZWZhdWx0U2VsZWN0ZWRJdGVtIiwiZnVuYyIsIm51bWJlciIsImJvb2wiLCJkZWZhdWx0UHJvcHMiLCJpIiwiU3RyaW5nIl0sIm1h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QUF0QjtBQUFBLEdBRE07QUFFcEJ6QyxZQUFVLEVBRlU7QUFHcEJDLGVBQWFoQixXQUhPO0FBSXBCcUIsb0JBQWtCLEtBSkU7QUFLcEJlLG1CQUFpQixHQUxHO0FBTXBCaEIsb0JBQWtCLEdBTkU7QUFPcEJlLHVCQUFxQixLQVBEO0FBUXBCaEIsY0FBWWY7QUFSUSxDO2VBbEJIRSxZIiwiZmlsZSI6IkF1dG9jb21wbGV0ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgZnV6emFsZHJpbiBmcm9tICdmdXp6YWxkcmluLXBsdXMnXG5pbXBvcnQgRG93bnNoaWZ0IGZyb20gJ2Rvd25zaGlmdCdcbmltcG9ydCBWaXJ0dWFsTGlzdCBmcm9tICdyZWFjdC10aW55LXZpcnR1YWwtbGlzdCdcbmltcG9ydCB7IFBvcG92ZXIgfSBmcm9tICcuLi8uLi9wb3BvdmVyJ1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJy4uLy4uL3R5cG9ncmFwaHknXG5pbXBvcnQgeyBQYW5lIH0gZnJvbSAnLi4vLi4vbGF5ZXJzJ1xuaW1wb3J0IEF1dG9jb21wbGV0ZUl0ZW0gZnJvbSAnLi9BdXRvY29tcGxldGVJdGVtJ1xuXG5jb25zdCBmdXp6eUZpbHRlciA9IChpdGVtcywgaW5wdXQpID0+IGZ1enphbGRyaW4uZmlsdGVyKGl0ZW1zLCBpbnB1dClcblxuY29uc3QgYXV0b2NvbXBsZXRlSXRlbVJlbmRlcmVyID0gcHJvcHMgPT4gPEF1dG9jb21wbGV0ZUl0ZW0gey4uLnByb3BzfSAvPlxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vcGF5cGFsL2Rvd25zaGlmdC9pc3N1ZXMvMTY0XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdXRvY29tcGxldGUgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICB0aXRsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm5vZGVdKSxcbiAgICBpdGVtczogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gICAgc2VsZWN0ZWRJdGVtOiBQcm9wVHlwZXMuYW55LFxuICAgIGRlZmF1bHRTZWxlY3RlZEl0ZW06IFByb3BUeXBlcy5hbnksXG4gICAgaXRlbVRvU3RyaW5nOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIGl0ZW1TaXplOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHJlbmRlckl0ZW06IFByb3BUeXBlcy5mdW5jLFxuICAgIGl0ZW1zRmlsdGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBpc0ZpbHRlckRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBwb3BvdmVyTWluV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgcG9wb3Zlck1heEhlaWdodDogUHJvcFR5cGVzLm51bWJlcixcbiAgICB1c2VTbWFydFBvc2l0aW9uaW5nOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAuLi5Eb3duc2hpZnQucHJvcFR5cGVzXG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGl0ZW1Ub1N0cmluZzogaSA9PiAoaSA/IFN0cmluZyhpKSA6ICcnKSxcbiAgICBpdGVtU2l6ZTogMzIsXG4gICAgaXRlbXNGaWx0ZXI6IGZ1enp5RmlsdGVyLFxuICAgIGlzRmlsdGVyRGlzYWJsZWQ6IGZhbHNlLFxuICAgIHBvcG92ZXJNaW5XaWR0aDogMjAwLFxuICAgIHBvcG92ZXJNYXhIZWlnaHQ6IDI0MCxcbiAgICB1c2VTbWFydFBvc2l0aW9uaW5nOiBmYWxzZSxcbiAgICByZW5kZXJJdGVtOiBhdXRvY29tcGxldGVJdGVtUmVuZGVyZXJcbiAgfVxuXG4gIHJlbmRlclJlc3VsdHMgPSAoe1xuICAgIHdpZHRoLFxuICAgIGlucHV0VmFsdWUsXG4gICAgaGlnaGxpZ2h0ZWRJbmRleCxcbiAgICBzZWxlY3RJdGVtQXRJbmRleCxcbiAgICBzZWxlY3RlZEl0ZW0sXG4gICAgZ2V0SXRlbVByb3BzXG4gIH0pID0+IHtcbiAgICBjb25zdCB7XG4gICAgICB0aXRsZSxcbiAgICAgIGl0ZW1TaXplLFxuICAgICAgaXRlbXNGaWx0ZXIsXG4gICAgICBpdGVtczogb3JpZ2luYWxJdGVtcyxcbiAgICAgIGl0ZW1Ub1N0cmluZyxcbiAgICAgIHJlbmRlckl0ZW0sXG4gICAgICBwb3BvdmVyTWF4SGVpZ2h0LFxuICAgICAgaXNGaWx0ZXJEaXNhYmxlZFxuICAgIH0gPSB0aGlzLnByb3BzXG5cbiAgICBjb25zdCBpdGVtcyA9XG4gICAgICBpc0ZpbHRlckRpc2FibGVkIHx8IGlucHV0VmFsdWUudHJpbSgpID09PSAnJ1xuICAgICAgICA/IG9yaWdpbmFsSXRlbXNcbiAgICAgICAgOiBpdGVtc0ZpbHRlcihvcmlnaW5hbEl0ZW1zLCBpbnB1dFZhbHVlKVxuXG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGxcblxuICAgIHJldHVybiAoXG4gICAgICA8UGFuZSB3aWR0aD17d2lkdGh9PlxuICAgICAgICB7dGl0bGUgJiYgKFxuICAgICAgICAgIDxQYW5lIHBhZGRpbmc9ezh9IGJvcmRlckJvdHRvbT1cImV4dHJhTXV0ZWRcIj5cbiAgICAgICAgICAgIDxUZXh0IHNpemU9ezIwMH0gY29sb3I9XCJtdXRlZFwiIGlzVXBwZXJjYXNlPlxuICAgICAgICAgICAgICB7dGl0bGV9XG4gICAgICAgICAgICA8L1RleHQ+XG4gICAgICAgICAgPC9QYW5lPlxuICAgICAgICApfVxuICAgICAgICB7aXRlbXMubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgICAgPFZpcnR1YWxMaXN0XG4gICAgICAgICAgICB3aWR0aD1cIjEwMCVcIlxuICAgICAgICAgICAgaGVpZ2h0PXtNYXRoLm1pbihpdGVtcy5sZW5ndGggKiBpdGVtU2l6ZSwgcG9wb3Zlck1heEhlaWdodCl9XG4gICAgICAgICAgICBpdGVtU2l6ZT17aXRlbVNpemV9XG4gICAgICAgICAgICBpdGVtQ291bnQ9e2l0ZW1zLmxlbmd0aH1cbiAgICAgICAgICAgIHNjcm9sbFRvSW5kZXg9e2hpZ2hsaWdodGVkSW5kZXggfHwgMH1cbiAgICAgICAgICAgIG92ZXJzY2FuQ291bnQ9ezN9XG4gICAgICAgICAgICBzY3JvbGxUb0FsaWdubWVudD1cImF1dG9cIlxuICAgICAgICAgICAgcmVuZGVySXRlbT17KHsgaW5kZXgsIHN0eWxlIH0pID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2luZGV4XVxuICAgICAgICAgICAgICBjb25zdCBpdGVtU3RyaW5nID0gaXRlbVRvU3RyaW5nKGl0ZW0pXG4gICAgICAgICAgICAgIHJldHVybiByZW5kZXJJdGVtKFxuICAgICAgICAgICAgICAgIGdldEl0ZW1Qcm9wcyh7XG4gICAgICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICAgICAga2V5OiBpdGVtU3RyaW5nLFxuICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICBzdHlsZSxcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBpdGVtU3RyaW5nLFxuICAgICAgICAgICAgICAgICAgb25Nb3VzZVVwOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdEl0ZW1BdEluZGV4KGluZGV4KVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGlzU2VsZWN0ZWQ6IHNlbGVjdGVkSXRlbSA9PT0gaXRlbSxcbiAgICAgICAgICAgICAgICAgIGlzSGlnaGxpZ2h0ZWQ6IGhpZ2hsaWdodGVkSW5kZXggPT09IGluZGV4XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAvPlxuICAgICAgICApfVxuICAgICAgPC9QYW5lPlxuICAgIClcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBjaGlsZHJlbixcbiAgICAgIGl0ZW1TaXplLFxuICAgICAgcmVuZGVySXRlbSxcbiAgICAgIGl0ZW1zRmlsdGVyLFxuICAgICAgcG9wb3Zlck1heEhlaWdodCxcbiAgICAgIHVzZVNtYXJ0UG9zaXRpb25pbmcsXG4gICAgICBwb3BvdmVyTWluV2lkdGgsXG4gICAgICAuLi5wcm9wc1xuICAgIH0gPSB0aGlzLnByb3BzXG5cbiAgICByZXR1cm4gKFxuICAgICAgPERvd25zaGlmdCB7Li4ucHJvcHN9PlxuICAgICAgICB7KHtcbiAgICAgICAgICBpc09wZW4sXG4gICAgICAgICAgaW5wdXRWYWx1ZSxcbiAgICAgICAgICBnZXRJdGVtUHJvcHMsXG4gICAgICAgICAgc2VsZWN0ZWRJdGVtLFxuICAgICAgICAgIGhpZ2hsaWdodGVkSW5kZXgsXG4gICAgICAgICAgc2VsZWN0SXRlbUF0SW5kZXgsXG4gICAgICAgICAgLi4ucmVzdERvd25zaGlmdFByb3BzXG4gICAgICAgIH0pID0+IChcbiAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgPFBvcG92ZXJcbiAgICAgICAgICAgICAgaXNPcGVuPXtpc09wZW59XG4gICAgICAgICAgICAgIG1pbldpZHRoPXtwb3BvdmVyTWluV2lkdGh9XG4gICAgICAgICAgICAgIGNvbnRlbnQ9eyh7IHRhcmdldFJlY3QgfSkgPT5cbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclJlc3VsdHMoe1xuICAgICAgICAgICAgICAgICAgd2lkdGg6IE1hdGgubWF4KHRhcmdldFJlY3Qud2lkdGgsIHBvcG92ZXJNaW5XaWR0aCksXG4gICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlLFxuICAgICAgICAgICAgICAgICAgZ2V0SXRlbVByb3BzLFxuICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRJdGVtLFxuICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0ZWRJbmRleCxcbiAgICAgICAgICAgICAgICAgIHNlbGVjdEl0ZW1BdEluZGV4XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBtaW5IZWlnaHQ9ezB9XG4gICAgICAgICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uPXswfVxuICAgICAgICAgICAgICB1c2VTbWFydFBvc2l0aW9uaW5nPXt1c2VTbWFydFBvc2l0aW9uaW5nfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7KHsgaXNPcGVuOiBpc09wZW5Qb3BvdmVyLCB0b2dnbGUsIGdldFJlZiwga2V5IH0pID0+XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4oe1xuICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgaXNPcGVuOiBpc09wZW5Qb3BvdmVyLFxuICAgICAgICAgICAgICAgICAgdG9nZ2xlLFxuICAgICAgICAgICAgICAgICAgZ2V0UmVmLFxuICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGVkSXRlbSxcbiAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodGVkSW5kZXgsXG4gICAgICAgICAgICAgICAgICBzZWxlY3RJdGVtQXRJbmRleCxcbiAgICAgICAgICAgICAgICAgIC4uLnJlc3REb3duc2hpZnRQcm9wc1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDwvUG9wb3Zlcj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgIDwvRG93bnNoaWZ0PlxuICAgIClcbiAgfVxufVxuIl19