var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import { Positioner } from '../../positioner';
import TooltipStateless from './TooltipStateless';

var Tooltip = function (_PureComponent) {
  _inherits(Tooltip, _PureComponent);

  function Tooltip(props, context) {
    _classCallCheck(this, Tooltip);

    var _this = _possibleConstructorReturn(this, (Tooltip.__proto__ || Object.getPrototypeOf(Tooltip)).call(this, props, context));

    _this.getTargetRect = function () {
      return _this.targetNode.getBoundingClientRect();
    };

    _this.getRef = function (ref) {
      _this.targetNode = ref;
    };

    _this.show = function () {
      if (_this.state.isShown) return;
      _this.setState({
        isShown: true,
        targetRect: _this.getTargetRect()
      });
    };

    _this.hide = function () {
      if (!_this.state.isShown) return;
      _this.setState({
        isShown: false,
        targetRect: _this.getTargetRect()
      });
    };

    _this.state = {
      isShown: false
    };
    return _this;
  }

  _createClass(Tooltip, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          isShown = _props.isShown,
          content = _props.content,
          children = _props.children,
          statelessProps = _props.statelessProps,
          props = _objectWithoutProperties(_props, ['isShown', 'content', 'children', 'statelessProps']);

      var _state = this.state,
          stateIsShown = _state.isShown,
          targetRect = _state.targetRect;


      var shown = isShown || stateIsShown;

      return [typeof children === 'function' ? children({
        targetRect: targetRect,
        show: this.show,
        hide: this.hide,
        getRef: this.getRef,
        isShown: shown,
        key: 'tooltip-child'
      }) : React.cloneElement(children, _extends({
        onMouseEnter: this.show,
        onMouseLeave: this.hide,
        innerRef: function innerRef(ref) {
          _this2.getRef(ref);
        }
      }, shown ? { 'data-tooltip-opened': true } : {}, {
        key: 'tooltip-child'
      })), React.createElement(
        Positioner,
        _extends({
          key: 'tooltip-positioner',
          targetRect: targetRect,
          isShown: shown,
          initialScale: 0.95,
          targetOffset: 4
        }, props),
        function (_ref) {
          var css = _ref.css,
              style = _ref.style,
              state = _ref.state,
              getRef = _ref.getRef;
          return React.createElement(
            TooltipStateless,
            _extends({
              innerRef: function innerRef(ref) {
                return getRef(ref);
              },
              'data-state': state,
              css: css,
              style: style
            }, statelessProps),
            content
          );
        }
      )];
    }
  }]);

  return Tooltip;
}(PureComponent);

Tooltip.propTypes = _extends({}, Positioner.propTypes, {
  content: PropTypes.node,
  isShown: PropTypes.bool,
  children: PropTypes.node,
  tooltipProps: PropTypes.object,
  statelessProps: PropTypes.objectOf(TooltipStateless.propTypes)
});
export default Tooltip;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90b29sdGlwL3NyYy9Ub29sdGlwLmpzIl0sIm5hbWVzIjpbIlJlYWN0IiwiUHVyZUNvbXBvbmVudCIsIlByb3BUeXBlcyIsIlBvc2l0aW9uZXIiLCJUb29sdGlwU3RhdGVsZXNzIiwiVG9vbHRpcCIsInByb3BzIiwiY29udGV4dCIsImdldFRhcmdldFJlY3QiLCJ0YXJnZXROb2RlIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZ2V0UmVmIiwicmVmIiwic2hvdyIsInN0YXRlIiwiaXNTaG93biIsInNldFN0YXRlIiwidGFyZ2V0UmVjdCIsImhpZGUiLCJjb250ZW50IiwiY2hpbGRyZW4iLCJzdGF0ZWxlc3NQcm9wcyIsInN0YXRlSXNTaG93biIsInNob3duIiwia2V5IiwiY2xvbmVFbGVtZW50Iiwib25Nb3VzZUVudGVyIiwib25Nb3VzZUxlYXZlIiwiaW5uZXJSZWYiLCJjc3MiLCJzdHlsZSIsInByb3BUeXBlcyIsIm5vZGUiLCJib29sIiwidG9vbHRpcFByb3BzIiwib2JqZWN0Iiwib2JqZWN0T2YiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLE9BQU9BLEtBQVAsSUFBZ0JDLGFBQWhCLFFBQXFDLE9BQXJDO0FBQ0EsT0FBT0MsU0FBUCxNQUFzQixZQUF0QjtBQUNBLFNBQVNDLFVBQVQsUUFBMkIsa0JBQTNCO0FBQ0EsT0FBT0MsZ0JBQVAsTUFBNkIsb0JBQTdCOztJQUVxQkMsTzs7O0FBVW5CLG1CQUFZQyxLQUFaLEVBQW1CQyxPQUFuQixFQUE0QjtBQUFBOztBQUFBLGtIQUNwQkQsS0FEb0IsRUFDYkMsT0FEYTs7QUFBQSxVQU81QkMsYUFQNEIsR0FPWjtBQUFBLGFBQU0sTUFBS0MsVUFBTCxDQUFnQkMscUJBQWhCLEVBQU47QUFBQSxLQVBZOztBQUFBLFVBUzVCQyxNQVQ0QixHQVNuQixlQUFPO0FBQ2QsWUFBS0YsVUFBTCxHQUFrQkcsR0FBbEI7QUFDRCxLQVgyQjs7QUFBQSxVQWE1QkMsSUFiNEIsR0FhckIsWUFBTTtBQUNYLFVBQUksTUFBS0MsS0FBTCxDQUFXQyxPQUFmLEVBQXdCO0FBQ3hCLFlBQUtDLFFBQUwsQ0FBYztBQUNaRCxpQkFBUyxJQURHO0FBRVpFLG9CQUFZLE1BQUtULGFBQUw7QUFGQSxPQUFkO0FBSUQsS0FuQjJCOztBQUFBLFVBcUI1QlUsSUFyQjRCLEdBcUJyQixZQUFNO0FBQ1gsVUFBSSxDQUFDLE1BQUtKLEtBQUwsQ0FBV0MsT0FBaEIsRUFBeUI7QUFDekIsWUFBS0MsUUFBTCxDQUFjO0FBQ1pELGlCQUFTLEtBREc7QUFFWkUsb0JBQVksTUFBS1QsYUFBTDtBQUZBLE9BQWQ7QUFJRCxLQTNCMkI7O0FBRTFCLFVBQUtNLEtBQUwsR0FBYTtBQUNYQyxlQUFTO0FBREUsS0FBYjtBQUYwQjtBQUszQjs7Ozs2QkF3QlE7QUFBQTs7QUFBQSxtQkFDMEQsS0FBS1QsS0FEL0Q7QUFBQSxVQUNDUyxPQURELFVBQ0NBLE9BREQ7QUFBQSxVQUNVSSxPQURWLFVBQ1VBLE9BRFY7QUFBQSxVQUNtQkMsUUFEbkIsVUFDbUJBLFFBRG5CO0FBQUEsVUFDNkJDLGNBRDdCLFVBQzZCQSxjQUQ3QjtBQUFBLFVBQ2dEZixLQURoRDs7QUFBQSxtQkFFdUMsS0FBS1EsS0FGNUM7QUFBQSxVQUVVUSxZQUZWLFVBRUNQLE9BRkQ7QUFBQSxVQUV3QkUsVUFGeEIsVUFFd0JBLFVBRnhCOzs7QUFJUCxVQUFNTSxRQUFRUixXQUFXTyxZQUF6Qjs7QUFFQSxhQUFPLENBQ0wsT0FBT0YsUUFBUCxLQUFvQixVQUFwQixHQUNJQSxTQUFTO0FBQ1BILDhCQURPO0FBRVBKLGNBQU0sS0FBS0EsSUFGSjtBQUdQSyxjQUFNLEtBQUtBLElBSEo7QUFJUFAsZ0JBQVEsS0FBS0EsTUFKTjtBQUtQSSxpQkFBU1EsS0FMRjtBQU1QQyxhQUFLO0FBTkUsT0FBVCxDQURKLEdBU0l4QixNQUFNeUIsWUFBTixDQUFtQkwsUUFBbkI7QUFDRU0sc0JBQWMsS0FBS2IsSUFEckI7QUFFRWMsc0JBQWMsS0FBS1QsSUFGckI7QUFHRVUsa0JBQVUsdUJBQU87QUFDZixpQkFBS2pCLE1BQUwsQ0FBWUMsR0FBWjtBQUNEO0FBTEgsU0FNTVcsUUFBUSxFQUFFLHVCQUF1QixJQUF6QixFQUFSLEdBQTBDLEVBTmhEO0FBT0VDLGFBQUs7QUFQUCxTQVZDLEVBbUJMO0FBQUMsa0JBQUQ7QUFBQTtBQUNFLGVBQUksb0JBRE47QUFFRSxzQkFBWVAsVUFGZDtBQUdFLG1CQUFTTSxLQUhYO0FBSUUsd0JBQWMsSUFKaEI7QUFLRSx3QkFBYztBQUxoQixXQU1NakIsS0FOTjtBQVFHO0FBQUEsY0FBR3VCLEdBQUgsUUFBR0EsR0FBSDtBQUFBLGNBQVFDLEtBQVIsUUFBUUEsS0FBUjtBQUFBLGNBQWVoQixLQUFmLFFBQWVBLEtBQWY7QUFBQSxjQUFzQkgsTUFBdEIsUUFBc0JBLE1BQXRCO0FBQUEsaUJBQ0M7QUFBQyw0QkFBRDtBQUFBO0FBQ0Usd0JBQVU7QUFBQSx1QkFBT0EsT0FBT0MsR0FBUCxDQUFQO0FBQUEsZUFEWjtBQUVFLDRCQUFZRSxLQUZkO0FBR0UsbUJBQUtlLEdBSFA7QUFJRSxxQkFBT0M7QUFKVCxlQUtNVCxjQUxOO0FBT0dGO0FBUEgsV0FERDtBQUFBO0FBUkgsT0FuQkssQ0FBUDtBQXdDRDs7OztFQXJGa0NsQixhOztBQUFoQkksTyxDQUNaMEIsUyxnQkFDRjVCLFdBQVc0QixTO0FBQ2RaLFdBQVNqQixVQUFVOEIsSTtBQUNuQmpCLFdBQVNiLFVBQVUrQixJO0FBQ25CYixZQUFVbEIsVUFBVThCLEk7QUFDcEJFLGdCQUFjaEMsVUFBVWlDLE07QUFDeEJkLGtCQUFnQm5CLFVBQVVrQyxRQUFWLENBQW1CaEMsaUJBQWlCMkIsU0FBcEM7O2VBUEMxQixPIiwiZmlsZSI6IlRvb2x0aXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJ1xuaW1wb3J0IHsgUG9zaXRpb25lciB9IGZyb20gJy4uLy4uL3Bvc2l0aW9uZXInXG5pbXBvcnQgVG9vbHRpcFN0YXRlbGVzcyBmcm9tICcuL1Rvb2x0aXBTdGF0ZWxlc3MnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAuLi5Qb3NpdGlvbmVyLnByb3BUeXBlcyxcbiAgICBjb250ZW50OiBQcm9wVHlwZXMubm9kZSxcbiAgICBpc1Nob3duOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gICAgdG9vbHRpcFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIHN0YXRlbGVzc1Byb3BzOiBQcm9wVHlwZXMub2JqZWN0T2YoVG9vbHRpcFN0YXRlbGVzcy5wcm9wVHlwZXMpXG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xuICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpc1Nob3duOiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGdldFRhcmdldFJlY3QgPSAoKSA9PiB0aGlzLnRhcmdldE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblxuICBnZXRSZWYgPSByZWYgPT4ge1xuICAgIHRoaXMudGFyZ2V0Tm9kZSA9IHJlZlxuICB9XG5cbiAgc2hvdyA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5zdGF0ZS5pc1Nob3duKSByZXR1cm5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGlzU2hvd246IHRydWUsXG4gICAgICB0YXJnZXRSZWN0OiB0aGlzLmdldFRhcmdldFJlY3QoKVxuICAgIH0pXG4gIH1cblxuICBoaWRlID0gKCkgPT4ge1xuICAgIGlmICghdGhpcy5zdGF0ZS5pc1Nob3duKSByZXR1cm5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGlzU2hvd246IGZhbHNlLFxuICAgICAgdGFyZ2V0UmVjdDogdGhpcy5nZXRUYXJnZXRSZWN0KClcbiAgICB9KVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgaXNTaG93biwgY29udGVudCwgY2hpbGRyZW4sIHN0YXRlbGVzc1Byb3BzLCAuLi5wcm9wcyB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHsgaXNTaG93bjogc3RhdGVJc1Nob3duLCB0YXJnZXRSZWN0IH0gPSB0aGlzLnN0YXRlXG5cbiAgICBjb25zdCBzaG93biA9IGlzU2hvd24gfHwgc3RhdGVJc1Nob3duXG5cbiAgICByZXR1cm4gW1xuICAgICAgdHlwZW9mIGNoaWxkcmVuID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRyZW4oe1xuICAgICAgICAgICAgdGFyZ2V0UmVjdCxcbiAgICAgICAgICAgIHNob3c6IHRoaXMuc2hvdyxcbiAgICAgICAgICAgIGhpZGU6IHRoaXMuaGlkZSxcbiAgICAgICAgICAgIGdldFJlZjogdGhpcy5nZXRSZWYsXG4gICAgICAgICAgICBpc1Nob3duOiBzaG93bixcbiAgICAgICAgICAgIGtleTogJ3Rvb2x0aXAtY2hpbGQnXG4gICAgICAgICAgfSlcbiAgICAgICAgOiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGRyZW4sIHtcbiAgICAgICAgICAgIG9uTW91c2VFbnRlcjogdGhpcy5zaG93LFxuICAgICAgICAgICAgb25Nb3VzZUxlYXZlOiB0aGlzLmhpZGUsXG4gICAgICAgICAgICBpbm5lclJlZjogcmVmID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5nZXRSZWYocmVmKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC4uLihzaG93biA/IHsgJ2RhdGEtdG9vbHRpcC1vcGVuZWQnOiB0cnVlIH0gOiB7fSksXG4gICAgICAgICAgICBrZXk6ICd0b29sdGlwLWNoaWxkJ1xuICAgICAgICAgIH0pLFxuICAgICAgPFBvc2l0aW9uZXJcbiAgICAgICAga2V5PVwidG9vbHRpcC1wb3NpdGlvbmVyXCJcbiAgICAgICAgdGFyZ2V0UmVjdD17dGFyZ2V0UmVjdH1cbiAgICAgICAgaXNTaG93bj17c2hvd259XG4gICAgICAgIGluaXRpYWxTY2FsZT17MC45NX1cbiAgICAgICAgdGFyZ2V0T2Zmc2V0PXs0fVxuICAgICAgICB7Li4ucHJvcHN9XG4gICAgICA+XG4gICAgICAgIHsoeyBjc3MsIHN0eWxlLCBzdGF0ZSwgZ2V0UmVmIH0pID0+IChcbiAgICAgICAgICA8VG9vbHRpcFN0YXRlbGVzc1xuICAgICAgICAgICAgaW5uZXJSZWY9e3JlZiA9PiBnZXRSZWYocmVmKX1cbiAgICAgICAgICAgIGRhdGEtc3RhdGU9e3N0YXRlfVxuICAgICAgICAgICAgY3NzPXtjc3N9XG4gICAgICAgICAgICBzdHlsZT17c3R5bGV9XG4gICAgICAgICAgICB7Li4uc3RhdGVsZXNzUHJvcHN9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2NvbnRlbnR9XG4gICAgICAgICAgPC9Ub29sdGlwU3RhdGVsZXNzPlxuICAgICAgICApfVxuICAgICAgPC9Qb3NpdGlvbmVyPlxuICAgIF1cbiAgfVxufVxuIl19