'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _objectValues = require('object-values');

var _objectValues2 = _interopRequireDefault(_objectValues);

var _Transition = require('react-transition-group/Transition');

var _Transition2 = _interopRequireDefault(_Transition);

var _portal = require('../../portal');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PositionerSides = {
  BOTTOM: 'bottom',
  TOP: 'top'
};

var animationEasing = {
  spring: 'cubic-bezier(0.175, 0.885, 0.320, 1.175)'
};

var initialState = function initialState() {
  return {
    top: null,
    left: null,
    side: null,
    transformOriginX: null
  };
};

var getCSS = function getCSS(_ref) {
  var targetOffset = _ref.targetOffset,
      initialScale = _ref.initialScale,
      animationDuration = _ref.animationDuration;
  return {
    position: 'absolute',
    opacity: 0,
    transition: 'all ' + animationDuration + 'ms ' + animationEasing.spring,
    transform: 'scale(' + initialScale + ') translateY(-1px)',
    '&[data-state="entering"][data-position="bottom"], &[data-state="entered"][data-position="bottom"]': {
      opacity: 1,
      visibility: 'visible',
      transform: 'scale(1) translateY(' + targetOffset + 'px)'
    },
    '&[data-state="entering"][data-position="top"], &[data-state="entered"][data-position="top"]': {
      opacity: 1,
      visibility: 'visible',
      transform: 'scale(1) translateY(-' + targetOffset + 'px)'
    },
    '&[data-state="exiting"]': {
      opacity: 0,
      transform: 'scale(1) translateY(0)'
    }
  };
};

var Positioner = function (_PureComponent) {
  _inherits(Positioner, _PureComponent);

  function Positioner(props, context) {
    _classCallCheck(this, Positioner);

    var _this = _possibleConstructorReturn(this, (Positioner.__proto__ || Object.getPrototypeOf(Positioner)).call(this, props, context));

    _this.getAnchors = function () {
      var targetRect = _this.props.targetRect;

      var bodyRect = document.body.getBoundingClientRect();
      var x = targetRect.left + targetRect.width / 2;
      return {
        top: {
          x: x,
          y: targetRect.top - bodyRect.top
        },
        bottom: {
          x: x,
          y: targetRect.bottom - bodyRect.top
        }
      };
    };

    _this.getRef = function (ref) {
      _this.positionerRef = ref;
      _this.props.innerRef(ref);
    };

    _this.handleEnter = function () {
      var _this$props = _this.props,
          useSmartPositioning = _this$props.useSmartPositioning,
          bodyOffset = _this$props.bodyOffset;

      var _this$getAnchors = _this.getAnchors(),
          top = _this$getAnchors.top,
          bottom = _this$getAnchors.bottom;

      var side = _this.props.side;

      // Smartly position the positioner when it overflows the body
      var viewportHeight = document.documentElement.clientHeight + window.scrollY;
      var viewportWidth = document.documentElement.clientWidth + window.scrollX;

      if (useSmartPositioning && _this.positionerRef.offsetHeight + bottom.y > viewportHeight) {
        side = 'top';
      }

      _this.positionerRef.setAttribute('data-position', side);

      var left = Math.max(bottom.x - _this.positionerRef.offsetWidth / 2, bodyOffset);
      left = Math.min(left, viewportWidth - _this.positionerRef.offsetWidth - bodyOffset);

      var transformOriginX = bottom.x - left;
      transformOriginX = Math.max(transformOriginX - bodyOffset, bottom.x - left);

      _this.setState({
        left: left,
        side: side,
        transformOriginX: transformOriginX,
        top: side === PositionerSides.BOTTOM ? bottom.y : top.y - _this.positionerRef.offsetHeight
      });
    };

    _this.handleExited = function () {
      _this.setState(initialState());
    };

    _this.state = initialState();
    return _this;
  }

  _createClass(Positioner, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          children = _props.children,
          zIndex = _props.zIndex,
          isShown = _props.isShown,
          targetRect = _props.targetRect,
          initialScale = _props.initialScale,
          targetOffset = _props.targetOffset,
          animationDuration = _props.animationDuration;
      var _state = this.state,
          left = _state.left,
          top = _state.top,
          side = _state.side,
          transformOriginX = _state.transformOriginX;


      var transformOrigin = transformOriginX + 'px ' + (side === PositionerSides.BOTTOM ? 'top' : 'bottom');

      return _react2.default.createElement(
        _portal.Portal,
        null,
        _react2.default.createElement(
          _Transition2.default,
          {
            'in': isShown,
            timeout: animationDuration,
            onEnter: this.handleEnter,
            onExited: this.handleExited,
            unmountOnExit: true
          },
          function (state) {
            return children({
              top: top,
              left: left,
              side: side,
              state: state,
              zIndex: zIndex,
              css: getCSS({ targetOffset: targetOffset, initialScale: initialScale, animationDuration: animationDuration }),
              style: {
                left: left,
                top: top,
                transformOrigin: transformOrigin,
                zIndex: zIndex
              },
              getRef: _this2.getRef,
              targetRect: targetRect,
              transformOrigin: transformOrigin,
              animationDuration: animationDuration
            });
          }
        )
      );
    }
  }]);

  return Positioner;
}(_react.PureComponent);

Positioner.propTypes = {
  side: _propTypes2.default.oneOf((0, _objectValues2.default)(PositionerSides)),
  zIndex: _propTypes2.default.number,
  isShown: _propTypes2.default.bool,
  children: _propTypes2.default.func,
  innerRef: _propTypes2.default.func,
  bodyOffset: _propTypes2.default.number,
  targetRect: _propTypes2.default.object,
  targetOffset: _propTypes2.default.number,
  initialScale: _propTypes2.default.number,
  animationDuration: _propTypes2.default.number,
  useSmartPositioning: _propTypes2.default.bool
};
Positioner.defaultProps = {
  innerRef: function innerRef() {},
  side: PositionerSides.BOTTOM,
  zIndex: 40,
  bodyOffset: 4,
  targetOffset: 8,
  initialScale: 0.9,
  animationDuration: 300,
  useSmartPositioning: true
};
exports.default = Positioner;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wb3NpdGlvbmVyL3NyYy9Qb3NpdGlvbmVyLmpzIl0sIm5hbWVzIjpbIlBvc2l0aW9uZXJTaWRlcyIsIkJPVFRPTSIsIlRPUCIsImFuaW1hdGlvbkVhc2luZyIsInNwcmluZyIsImluaXRpYWxTdGF0ZSIsInRvcCIsImxlZnQiLCJzaWRlIiwidHJhbnNmb3JtT3JpZ2luWCIsImdldENTUyIsInRhcmdldE9mZnNldCIsImluaXRpYWxTY2FsZSIsImFuaW1hdGlvbkR1cmF0aW9uIiwicG9zaXRpb24iLCJvcGFjaXR5IiwidHJhbnNpdGlvbiIsInRyYW5zZm9ybSIsInZpc2liaWxpdHkiLCJQb3NpdGlvbmVyIiwicHJvcHMiLCJjb250ZXh0IiwiZ2V0QW5jaG9ycyIsInRhcmdldFJlY3QiLCJib2R5UmVjdCIsImRvY3VtZW50IiwiYm9keSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIngiLCJ3aWR0aCIsInkiLCJib3R0b20iLCJnZXRSZWYiLCJwb3NpdGlvbmVyUmVmIiwicmVmIiwiaW5uZXJSZWYiLCJoYW5kbGVFbnRlciIsInVzZVNtYXJ0UG9zaXRpb25pbmciLCJib2R5T2Zmc2V0Iiwidmlld3BvcnRIZWlnaHQiLCJkb2N1bWVudEVsZW1lbnQiLCJjbGllbnRIZWlnaHQiLCJ3aW5kb3ciLCJzY3JvbGxZIiwidmlld3BvcnRXaWR0aCIsImNsaWVudFdpZHRoIiwic2Nyb2xsWCIsIm9mZnNldEhlaWdodCIsInNldEF0dHJpYnV0ZSIsIk1hdGgiLCJtYXgiLCJvZmZzZXRXaWR0aCIsIm1pbiIsInNldFN0YXRlIiwiaGFuZGxlRXhpdGVkIiwic3RhdGUiLCJjaGlsZHJlbiIsInpJbmRleCIsImlzU2hvd24iLCJ0cmFuc2Zvcm1PcmlnaW4iLCJjc3MiLCJzdHlsZSIsInByb3BUeXBlcyIsIm9uZU9mIiwibnVtYmVyIiwiYm9vbCIsImZ1bmMiLCJvYmplY3QiLCJkZWZhdWx0UHJvcHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7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LG9CQUFVcUQsTUFSUDtBQVNqQnBELGdCQUFjLG9CQUFVb0QsTUFUUDtBQVVqQm5ELHFCQUFtQixvQkFBVW1ELE1BVlo7QUFXakIzQix1QkFBcUIsb0JBQVU0QjtBQVhkLEM7QUFEQTlDLFUsQ0FlWmlELFksR0FBZTtBQUNwQmpDLFlBQVUsb0JBQU0sQ0FBRSxDQURFO0FBRXBCM0IsUUFBTVIsZ0JBQWdCQyxNQUZGO0FBR3BCd0QsVUFBUSxFQUhZO0FBSXBCbkIsY0FBWSxDQUpRO0FBS3BCM0IsZ0JBQWMsQ0FMTTtBQU1wQkMsZ0JBQWMsR0FOTTtBQU9wQkMscUJBQW1CLEdBUEM7QUFRcEJ3Qix1QkFBcUI7QUFSRCxDO2tCQWZIbEIsVSIsImZpbGUiOiJQb3NpdGlvbmVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcydcbmltcG9ydCBvYmplY3RWYWx1ZXMgZnJvbSAnb2JqZWN0LXZhbHVlcydcbmltcG9ydCBUcmFuc2l0aW9uIGZyb20gJ3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvVHJhbnNpdGlvbidcbmltcG9ydCB7IFBvcnRhbCB9IGZyb20gJy4uLy4uL3BvcnRhbCdcblxuY29uc3QgUG9zaXRpb25lclNpZGVzID0ge1xuICBCT1RUT006ICdib3R0b20nLFxuICBUT1A6ICd0b3AnXG59XG5cbmNvbnN0IGFuaW1hdGlvbkVhc2luZyA9IHtcbiAgc3ByaW5nOiBgY3ViaWMtYmV6aWVyKDAuMTc1LCAwLjg4NSwgMC4zMjAsIDEuMTc1KWBcbn1cblxuY29uc3QgaW5pdGlhbFN0YXRlID0gKCkgPT4gKHtcbiAgdG9wOiBudWxsLFxuICBsZWZ0OiBudWxsLFxuICBzaWRlOiBudWxsLFxuICB0cmFuc2Zvcm1PcmlnaW5YOiBudWxsXG59KVxuXG5jb25zdCBnZXRDU1MgPSAoeyB0YXJnZXRPZmZzZXQsIGluaXRpYWxTY2FsZSwgYW5pbWF0aW9uRHVyYXRpb24gfSkgPT4gKHtcbiAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gIG9wYWNpdHk6IDAsXG4gIHRyYW5zaXRpb246IGBhbGwgJHthbmltYXRpb25EdXJhdGlvbn1tcyAke2FuaW1hdGlvbkVhc2luZy5zcHJpbmd9YCxcbiAgdHJhbnNmb3JtOiBgc2NhbGUoJHtpbml0aWFsU2NhbGV9KSB0cmFuc2xhdGVZKC0xcHgpYCxcbiAgJyZbZGF0YS1zdGF0ZT1cImVudGVyaW5nXCJdW2RhdGEtcG9zaXRpb249XCJib3R0b21cIl0sICZbZGF0YS1zdGF0ZT1cImVudGVyZWRcIl1bZGF0YS1wb3NpdGlvbj1cImJvdHRvbVwiXSc6IHtcbiAgICBvcGFjaXR5OiAxLFxuICAgIHZpc2liaWxpdHk6ICd2aXNpYmxlJyxcbiAgICB0cmFuc2Zvcm06IGBzY2FsZSgxKSB0cmFuc2xhdGVZKCR7dGFyZ2V0T2Zmc2V0fXB4KWBcbiAgfSxcbiAgJyZbZGF0YS1zdGF0ZT1cImVudGVyaW5nXCJdW2RhdGEtcG9zaXRpb249XCJ0b3BcIl0sICZbZGF0YS1zdGF0ZT1cImVudGVyZWRcIl1bZGF0YS1wb3NpdGlvbj1cInRvcFwiXSc6IHtcbiAgICBvcGFjaXR5OiAxLFxuICAgIHZpc2liaWxpdHk6ICd2aXNpYmxlJyxcbiAgICB0cmFuc2Zvcm06IGBzY2FsZSgxKSB0cmFuc2xhdGVZKC0ke3RhcmdldE9mZnNldH1weClgXG4gIH0sXG4gICcmW2RhdGEtc3RhdGU9XCJleGl0aW5nXCJdJzoge1xuICAgIG9wYWNpdHk6IDAsXG4gICAgdHJhbnNmb3JtOiAnc2NhbGUoMSkgdHJhbnNsYXRlWSgwKSdcbiAgfVxufSlcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9zaXRpb25lciBleHRlbmRzIFB1cmVDb21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIHNpZGU6IFByb3BUeXBlcy5vbmVPZihvYmplY3RWYWx1ZXMoUG9zaXRpb25lclNpZGVzKSksXG4gICAgekluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGlzU2hvd246IFByb3BUeXBlcy5ib29sLFxuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgYm9keU9mZnNldDogUHJvcFR5cGVzLm51bWJlcixcbiAgICB0YXJnZXRSZWN0OiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIHRhcmdldE9mZnNldDogUHJvcFR5cGVzLm51bWJlcixcbiAgICBpbml0aWFsU2NhbGU6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IFByb3BUeXBlcy5udW1iZXIsXG4gICAgdXNlU21hcnRQb3NpdGlvbmluZzogUHJvcFR5cGVzLmJvb2xcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgaW5uZXJSZWY6ICgpID0+IHt9LFxuICAgIHNpZGU6IFBvc2l0aW9uZXJTaWRlcy5CT1RUT00sXG4gICAgekluZGV4OiA0MCxcbiAgICBib2R5T2Zmc2V0OiA0LFxuICAgIHRhcmdldE9mZnNldDogOCxcbiAgICBpbml0aWFsU2NhbGU6IDAuOSxcbiAgICBhbmltYXRpb25EdXJhdGlvbjogMzAwLFxuICAgIHVzZVNtYXJ0UG9zaXRpb25pbmc6IHRydWVcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XG4gICAgc3VwZXIocHJvcHMsIGNvbnRleHQpXG4gICAgdGhpcy5zdGF0ZSA9IGluaXRpYWxTdGF0ZSgpXG4gIH1cblxuICBnZXRBbmNob3JzID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgdGFyZ2V0UmVjdCB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IGJvZHlSZWN0ID0gZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGNvbnN0IHggPSB0YXJnZXRSZWN0LmxlZnQgKyB0YXJnZXRSZWN0LndpZHRoIC8gMlxuICAgIHJldHVybiB7XG4gICAgICB0b3A6IHtcbiAgICAgICAgeCxcbiAgICAgICAgeTogdGFyZ2V0UmVjdC50b3AgLSBib2R5UmVjdC50b3BcbiAgICAgIH0sXG4gICAgICBib3R0b206IHtcbiAgICAgICAgeCxcbiAgICAgICAgeTogdGFyZ2V0UmVjdC5ib3R0b20gLSBib2R5UmVjdC50b3BcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXRSZWYgPSByZWYgPT4ge1xuICAgIHRoaXMucG9zaXRpb25lclJlZiA9IHJlZlxuICAgIHRoaXMucHJvcHMuaW5uZXJSZWYocmVmKVxuICB9XG5cbiAgaGFuZGxlRW50ZXIgPSAoKSA9PiB7XG4gICAgY29uc3QgeyB1c2VTbWFydFBvc2l0aW9uaW5nLCBib2R5T2Zmc2V0IH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgeyB0b3AsIGJvdHRvbSB9ID0gdGhpcy5nZXRBbmNob3JzKClcbiAgICBsZXQgc2lkZSA9IHRoaXMucHJvcHMuc2lkZVxuXG4gICAgLy8gU21hcnRseSBwb3NpdGlvbiB0aGUgcG9zaXRpb25lciB3aGVuIGl0IG92ZXJmbG93cyB0aGUgYm9keVxuICAgIGNvbnN0IHZpZXdwb3J0SGVpZ2h0ID1cbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgKyB3aW5kb3cuc2Nyb2xsWVxuICAgIGNvbnN0IHZpZXdwb3J0V2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggKyB3aW5kb3cuc2Nyb2xsWFxuXG4gICAgaWYgKFxuICAgICAgdXNlU21hcnRQb3NpdGlvbmluZyAmJlxuICAgICAgdGhpcy5wb3NpdGlvbmVyUmVmLm9mZnNldEhlaWdodCArIGJvdHRvbS55ID4gdmlld3BvcnRIZWlnaHRcbiAgICApIHtcbiAgICAgIHNpZGUgPSAndG9wJ1xuICAgIH1cblxuICAgIHRoaXMucG9zaXRpb25lclJlZi5zZXRBdHRyaWJ1dGUoJ2RhdGEtcG9zaXRpb24nLCBzaWRlKVxuXG4gICAgbGV0IGxlZnQgPSBNYXRoLm1heChcbiAgICAgIGJvdHRvbS54IC0gdGhpcy5wb3NpdGlvbmVyUmVmLm9mZnNldFdpZHRoIC8gMixcbiAgICAgIGJvZHlPZmZzZXRcbiAgICApXG4gICAgbGVmdCA9IE1hdGgubWluKFxuICAgICAgbGVmdCxcbiAgICAgIHZpZXdwb3J0V2lkdGggLSB0aGlzLnBvc2l0aW9uZXJSZWYub2Zmc2V0V2lkdGggLSBib2R5T2Zmc2V0XG4gICAgKVxuXG4gICAgbGV0IHRyYW5zZm9ybU9yaWdpblggPSBib3R0b20ueCAtIGxlZnRcbiAgICB0cmFuc2Zvcm1PcmlnaW5YID0gTWF0aC5tYXgodHJhbnNmb3JtT3JpZ2luWCAtIGJvZHlPZmZzZXQsIGJvdHRvbS54IC0gbGVmdClcblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgbGVmdCxcbiAgICAgIHNpZGUsXG4gICAgICB0cmFuc2Zvcm1PcmlnaW5YLFxuICAgICAgdG9wOlxuICAgICAgICBzaWRlID09PSBQb3NpdGlvbmVyU2lkZXMuQk9UVE9NXG4gICAgICAgICAgPyBib3R0b20ueVxuICAgICAgICAgIDogdG9wLnkgLSB0aGlzLnBvc2l0aW9uZXJSZWYub2Zmc2V0SGVpZ2h0XG4gICAgfSlcbiAgfVxuXG4gIGhhbmRsZUV4aXRlZCA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKGluaXRpYWxTdGF0ZSgpKVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgekluZGV4LFxuICAgICAgaXNTaG93bixcbiAgICAgIHRhcmdldFJlY3QsXG4gICAgICBpbml0aWFsU2NhbGUsXG4gICAgICB0YXJnZXRPZmZzZXQsXG4gICAgICBhbmltYXRpb25EdXJhdGlvblxuICAgIH0gPSB0aGlzLnByb3BzXG5cbiAgICBjb25zdCB7IGxlZnQsIHRvcCwgc2lkZSwgdHJhbnNmb3JtT3JpZ2luWCB9ID0gdGhpcy5zdGF0ZVxuXG4gICAgY29uc3QgdHJhbnNmb3JtT3JpZ2luID0gYCR7dHJhbnNmb3JtT3JpZ2luWH1weCAke1xuICAgICAgc2lkZSA9PT0gUG9zaXRpb25lclNpZGVzLkJPVFRPTSA/ICd0b3AnIDogJ2JvdHRvbSdcbiAgICB9YFxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxQb3J0YWw+XG4gICAgICAgIDxUcmFuc2l0aW9uXG4gICAgICAgICAgaW49e2lzU2hvd259XG4gICAgICAgICAgdGltZW91dD17YW5pbWF0aW9uRHVyYXRpb259XG4gICAgICAgICAgb25FbnRlcj17dGhpcy5oYW5kbGVFbnRlcn1cbiAgICAgICAgICBvbkV4aXRlZD17dGhpcy5oYW5kbGVFeGl0ZWR9XG4gICAgICAgICAgdW5tb3VudE9uRXhpdFxuICAgICAgICA+XG4gICAgICAgICAge3N0YXRlID0+XG4gICAgICAgICAgICBjaGlsZHJlbih7XG4gICAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgICAgc2lkZSxcbiAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgIHpJbmRleCxcbiAgICAgICAgICAgICAgY3NzOiBnZXRDU1MoeyB0YXJnZXRPZmZzZXQsIGluaXRpYWxTY2FsZSwgYW5pbWF0aW9uRHVyYXRpb24gfSksXG4gICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luLFxuICAgICAgICAgICAgICAgIHpJbmRleFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBnZXRSZWY6IHRoaXMuZ2V0UmVmLFxuICAgICAgICAgICAgICB0YXJnZXRSZWN0LFxuICAgICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW4sXG4gICAgICAgICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgPC9UcmFuc2l0aW9uPlxuICAgICAgPC9Qb3J0YWw+XG4gICAgKVxuICB9XG59XG4iXX0=