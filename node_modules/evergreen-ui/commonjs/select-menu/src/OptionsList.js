'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _fuzzaldrinPlus = require('fuzzaldrin-plus');

var _fuzzaldrinPlus2 = _interopRequireDefault(_fuzzaldrinPlus);

var _reactTinyVirtualList = require('react-tiny-virtual-list');

var _reactTinyVirtualList2 = _interopRequireDefault(_reactTinyVirtualList);

var _layers = require('../../layers');

var _table = require('../../table');

var _OptionShapePropType = require('./OptionShapePropType');

var _OptionShapePropType2 = _interopRequireDefault(_OptionShapePropType);

var _Option = require('./Option');

var _Option2 = _interopRequireDefault(_Option);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Fuzzaldrin-plus is the default filter, but you can use your own
 * as long as they follow the following signature:
 * @param options <Array[String]> - ['label', 'label2', ...]
 * @param input <String>
 */
var fuzzyFilter = function fuzzyFilter(options, input) {
  return _fuzzaldrinPlus2.default.filter(options, input);
};

/**
 * This is the default item renderer of options
 * you can pass custom renderers as long as they work the same as the Option
 */
var itemRenderer = function itemRenderer(props) {
  return _react2.default.createElement(_Option2.default, props);
};

var OptionsList = function (_PureComponent) {
  _inherits(OptionsList, _PureComponent);

  function OptionsList(props, context) {
    _classCallCheck(this, OptionsList);

    var _this = _possibleConstructorReturn(this, (OptionsList.__proto__ || Object.getPrototypeOf(OptionsList)).call(this, props, context));

    _this.isSelected = function (item) {
      var selected = _this.state.selected;


      return Boolean(selected.find(function (selectedItem) {
        return selectedItem === item.value;
      }));
    };

    _this.search = function (options) {
      var optionsFilter = _this.props.optionsFilter;
      var searchValue = _this.state.searchValue;


      return searchValue.trim() === '' ? options // Return if no search query
      : optionsFilter(options.map(function (item) {
        return item.labelInList || item.label;
      }), searchValue).map(function (name) {
        return options.find(function (item) {
          return item.labelInList === name || item.label === name;
        });
      });
    };

    _this.handleChange = function (searchValue) {
      _this.setState({
        searchValue: searchValue
      });
    };

    _this.handleSelect = function (item) {
      _this.props.onSelect(item);
    };

    _this.assignSearchRef = function (ref) {
      _this.searchRef = ref;
    };

    _this.state = {
      searchValue: props.defaultSearchValue,
      selected: props.selected
    };
    return _this;
  }

  _createClass(OptionsList, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      var hasFilter = this.props.hasFilter;

      if (!hasFilter) return;
      /**
       * Hacky solution for broken autoFocus
       * https://github.com/segmentio/evergreen/issues/90
       */
      window.setTimeout(function () {
        _this2.searchRef.querySelector('input').focus();
      }, 1);
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.selected !== this.state.selected) {
        this.setState({
          selected: nextProps.selected
        });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var _props = this.props,
          originalOptions = _props.options,
          close = _props.close,
          width = _props.width,
          height = _props.height,
          onSelect = _props.onSelect,
          selected = _props.selected,
          hasFilter = _props.hasFilter,
          optionSize = _props.optionSize,
          _renderItem = _props.renderItem,
          placeholder = _props.placeholder,
          optionsFilter = _props.optionsFilter,
          defaultSearchValue = _props.defaultSearchValue,
          props = _objectWithoutProperties(_props, ['options', 'close', 'width', 'height', 'onSelect', 'selected', 'hasFilter', 'optionSize', 'renderItem', 'placeholder', 'optionsFilter', 'defaultSearchValue']);

      var options = this.search(originalOptions);
      var listHeight = height - (hasFilter ? 32 : 0);

      return _react2.default.createElement(
        _layers.Pane,
        _extends({
          height: height,
          width: width,
          display: 'flex',
          flexDirection: 'column'
        }, props),
        hasFilter && _react2.default.createElement(
          _table.TableHead,
          null,
          _react2.default.createElement(_table.SearchTableHeaderCell, {
            onChange: this.handleChange,
            innerRef: this.assignSearchRef,
            borderRight: null,
            height: 32
          })
        ),
        _react2.default.createElement(
          _layers.Pane,
          { flex: 1 },
          _react2.default.createElement(_reactTinyVirtualList2.default, {
            height: listHeight,
            width: '100%',
            itemSize: optionSize,
            itemCount: options.length,
            overscanCount: 3,
            scrollToAlignment: 'auto',
            renderItem: function renderItem(_ref) {
              var index = _ref.index,
                  style = _ref.style;

              var item = options[index];
              return _renderItem({
                key: item.value,
                label: item.label,
                style: style,
                height: optionSize,
                onSelect: function onSelect() {
                  return _this3.handleSelect(item);
                },
                isSelected: _this3.isSelected(item)
              });
            }
          })
        )
      );
    }
  }]);

  return OptionsList;
}(_react.PureComponent);

OptionsList.propTypes = {
  options: _propTypes2.default.arrayOf(_OptionShapePropType2.default),
  close: _propTypes2.default.func,
  height: _propTypes2.default.number,
  width: _propTypes2.default.number,

  /**
   * This holds the values of the options
   */
  selected: _propTypes2.default.arrayOf(_propTypes2.default.string),
  onSelect: _propTypes2.default.func,
  hasFilter: _propTypes2.default.bool,
  optionSize: _propTypes2.default.number,
  renderItem: _propTypes2.default.func,
  placeholder: _propTypes2.default.string,
  optionsFilter: _propTypes2.default.func,
  defaultSearchValue: _propTypes2.default.string
};
OptionsList.defaultProps = {
  options: [],
  /**
   * Including border bottom
   * For some reason passing height to TableRow doesn't work
   * TODO: fix hacky solution
   */
  optionSize: 33,
  onSelect: function onSelect() {},
  selected: [],
  renderItem: itemRenderer,
  optionsFilter: fuzzyFilter,
  placeholder: 'Filter...',
  defaultSearchValue: ''
};
exports.default = OptionsList;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zZWxlY3QtbWVudS9zcmMvT3B0aW9uc0xpc3QuanMiXSwibmFtZXMiOlsiZnV6enlGaWx0ZXIiLCJvcHRpb25zIiwiaW5wdXQiLCJmaWx0ZXIiLCJpdGVtUmVuZGVyZXIiLCJwcm9wcyIsIk9wdGlvbnNMaXN0IiwiY29udGV4dCIsImlzU2VsZWN0ZWQiLCJzZWxlY3RlZCIsInN0YXRlIiwiQm9vbGVhbiIsImZpbmQiLCJzZWxlY3RlZEl0ZW0iLCJpdGVtIiwidmFsdWUiLCJzZWFyY2giLCJvcHRpb25zRmlsdGVyIiwic2VhcmNoVmFsdWUiLCJ0cmltIiwibWFwIiwibGFiZWxJbkxpc3QiLCJsYWJlbCIsIm5hbWUiLCJoYW5kbGVDaGFuZ2UiLCJzZXRTdGF0ZSIsImhhbmRsZVNlbGVjdCIsIm9uU2VsZWN0IiwiYXNzaWduU2VhcmNoUmVmIiwic2VhcmNoUmVmIiwicmVmIiwiZGVmYXVsdFNlYXJjaFZhbHVlIiwiaGFzRmlsdGVyIiwid2luZG93Iiwic2V0VGltZW91dCIsInF1ZXJ5U2VsZWN0b3IiLCJmb2N1cyIsIm5leHRQcm9wcyIsIm9yaWdpbmFsT3B0aW9ucyIsImNsb3NlIiwid2lkdGgiLCJoZWlnaHQiLCJvcHRpb25TaXplIiwicmVuZGVySXRlbSIsInBsYWNlaG9sZGVyIiwibGlzdEhlaWdodCIsImxlbmd0aCIsImluZGV4Iiwic3R5bGUiLCJrZXkiLCJwcm9wVHlwZXMiLCJhcnJheU9mIiwiZnVuYyIsIm51bWJlciIsInN0cmluZyIsImJvb2wiLCJkZWZhdWx0UHJvcHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7OztBQU1BLElBQU1BLGNBQWMsU0FBZEEsV0FBYyxDQUFDQyxPQUFELEVBQVVDLEtBQVY7QUFBQSxTQUFvQix5QkFBV0MsTUFBWCxDQUFrQkYsT0FBbEIsRUFBMkJDLEtB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Q0FDWjRDLFMsR0FBWTtBQUNqQmpELFdBQVMsb0JBQVVrRCxPQUFWLCtCQURRO0FBRWpCWixTQUFPLG9CQUFVYSxJQUZBO0FBR2pCWCxVQUFRLG9CQUFVWSxNQUhEO0FBSWpCYixTQUFPLG9CQUFVYSxNQUpBOztBQU1qQjs7O0FBR0E1QyxZQUFVLG9CQUFVMEMsT0FBVixDQUFrQixvQkFBVUcsTUFBNUIsQ0FUTztBQVVqQjNCLFlBQVUsb0JBQVV5QixJQVZIO0FBV2pCcEIsYUFBVyxvQkFBVXVCLElBWEo7QUFZakJiLGNBQVksb0JBQVVXLE1BWkw7QUFhakJWLGNBQVksb0JBQVVTLElBYkw7QUFjakJSLGVBQWEsb0JBQVVVLE1BZE47QUFlakJyQyxpQkFBZSxvQkFBVW1DLElBZlI7QUFnQmpCckIsc0JBQW9CLG9CQUFVdUI7QUFoQmIsQztBQURBaEQsVyxDQW9CWmtELFksR0FBZTtBQUNwQnZELFdBQVMsRUFEVztBQUVwQjs7Ozs7QUFLQXlDLGNBQVksRUFQUTtBQVFwQmYsWUFBVSxvQkFBTSxDQUFFLENBUkU7QUFTcEJsQixZQUFVLEVBVFU7QUFVcEJrQyxjQUFZdkMsWUFWUTtBQVdwQmEsaUJBQWVqQixXQVhLO0FBWXBCNEMsZUFBYSxXQVpPO0FBYXBCYixzQkFBb0I7QUFiQSxDO2tCQXBCSHpCLFciLCJmaWxlIjoiT3B0aW9uc0xpc3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJ1xuaW1wb3J0IGZ1enphbGRyaW4gZnJvbSAnZnV6emFsZHJpbi1wbHVzJ1xuaW1wb3J0IFZpcnR1YWxMaXN0IGZyb20gJ3JlYWN0LXRpbnktdmlydHVhbC1saXN0J1xuaW1wb3J0IHsgUGFuZSB9IGZyb20gJy4uLy4uL2xheWVycydcbmltcG9ydCB7IFRhYmxlSGVhZCwgU2VhcmNoVGFibGVIZWFkZXJDZWxsIH0gZnJvbSAnLi4vLi4vdGFibGUnXG5pbXBvcnQgT3B0aW9uU2hhcGVQcm9wVHlwZSBmcm9tICcuL09wdGlvblNoYXBlUHJvcFR5cGUnXG5pbXBvcnQgT3B0aW9uIGZyb20gJy4vT3B0aW9uJ1xuXG4vKipcbiAqIEZ1enphbGRyaW4tcGx1cyBpcyB0aGUgZGVmYXVsdCBmaWx0ZXIsIGJ1dCB5b3UgY2FuIHVzZSB5b3VyIG93blxuICogYXMgbG9uZyBhcyB0aGV5IGZvbGxvdyB0aGUgZm9sbG93aW5nIHNpZ25hdHVyZTpcbiAqIEBwYXJhbSBvcHRpb25zIDxBcnJheVtTdHJpbmddPiAtIFsnbGFiZWwnLCAnbGFiZWwyJywgLi4uXVxuICogQHBhcmFtIGlucHV0IDxTdHJpbmc+XG4gKi9cbmNvbnN0IGZ1enp5RmlsdGVyID0gKG9wdGlvbnMsIGlucHV0KSA9PiBmdXp6YWxkcmluLmZpbHRlcihvcHRpb25zLCBpbnB1dClcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBkZWZhdWx0IGl0ZW0gcmVuZGVyZXIgb2Ygb3B0aW9uc1xuICogeW91IGNhbiBwYXNzIGN1c3RvbSByZW5kZXJlcnMgYXMgbG9uZyBhcyB0aGV5IHdvcmsgdGhlIHNhbWUgYXMgdGhlIE9wdGlvblxuICovXG5jb25zdCBpdGVtUmVuZGVyZXIgPSBwcm9wcyA9PiA8T3B0aW9uIHsuLi5wcm9wc30gLz5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3B0aW9uc0xpc3QgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBvcHRpb25zOiBQcm9wVHlwZXMuYXJyYXlPZihPcHRpb25TaGFwZVByb3BUeXBlKSxcbiAgICBjbG9zZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBob2xkcyB0aGUgdmFsdWVzIG9mIHRoZSBvcHRpb25zXG4gICAgICovXG4gICAgc2VsZWN0ZWQ6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpLFxuICAgIG9uU2VsZWN0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBoYXNGaWx0ZXI6IFByb3BUeXBlcy5ib29sLFxuICAgIG9wdGlvblNpemU6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgcmVuZGVySXRlbTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgcGxhY2Vob2xkZXI6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgb3B0aW9uc0ZpbHRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgZGVmYXVsdFNlYXJjaFZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nXG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIG9wdGlvbnM6IFtdLFxuICAgIC8qKlxuICAgICAqIEluY2x1ZGluZyBib3JkZXIgYm90dG9tXG4gICAgICogRm9yIHNvbWUgcmVhc29uIHBhc3NpbmcgaGVpZ2h0IHRvIFRhYmxlUm93IGRvZXNuJ3Qgd29ya1xuICAgICAqIFRPRE86IGZpeCBoYWNreSBzb2x1dGlvblxuICAgICAqL1xuICAgIG9wdGlvblNpemU6IDMzLFxuICAgIG9uU2VsZWN0OiAoKSA9PiB7fSxcbiAgICBzZWxlY3RlZDogW10sXG4gICAgcmVuZGVySXRlbTogaXRlbVJlbmRlcmVyLFxuICAgIG9wdGlvbnNGaWx0ZXI6IGZ1enp5RmlsdGVyLFxuICAgIHBsYWNlaG9sZGVyOiAnRmlsdGVyLi4uJyxcbiAgICBkZWZhdWx0U2VhcmNoVmFsdWU6ICcnXG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xuICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHNlYXJjaFZhbHVlOiBwcm9wcy5kZWZhdWx0U2VhcmNoVmFsdWUsXG4gICAgICBzZWxlY3RlZDogcHJvcHMuc2VsZWN0ZWRcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBjb25zdCB7IGhhc0ZpbHRlciB9ID0gdGhpcy5wcm9wc1xuICAgIGlmICghaGFzRmlsdGVyKSByZXR1cm5cbiAgICAvKipcbiAgICAgKiBIYWNreSBzb2x1dGlvbiBmb3IgYnJva2VuIGF1dG9Gb2N1c1xuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zZWdtZW50aW8vZXZlcmdyZWVuL2lzc3Vlcy85MFxuICAgICAqL1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuc2VhcmNoUmVmLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0JykuZm9jdXMoKVxuICAgIH0sIDEpXG4gIH1cblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMuc2VsZWN0ZWQgIT09IHRoaXMuc3RhdGUuc2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBzZWxlY3RlZDogbmV4dFByb3BzLnNlbGVjdGVkXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGlzU2VsZWN0ZWQgPSBpdGVtID0+IHtcbiAgICBjb25zdCB7IHNlbGVjdGVkIH0gPSB0aGlzLnN0YXRlXG5cbiAgICByZXR1cm4gQm9vbGVhbihzZWxlY3RlZC5maW5kKHNlbGVjdGVkSXRlbSA9PiBzZWxlY3RlZEl0ZW0gPT09IGl0ZW0udmFsdWUpKVxuICB9XG5cbiAgc2VhcmNoID0gb3B0aW9ucyA9PiB7XG4gICAgY29uc3QgeyBvcHRpb25zRmlsdGVyIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgeyBzZWFyY2hWYWx1ZSB9ID0gdGhpcy5zdGF0ZVxuXG4gICAgcmV0dXJuIHNlYXJjaFZhbHVlLnRyaW0oKSA9PT0gJydcbiAgICAgID8gb3B0aW9ucyAvLyBSZXR1cm4gaWYgbm8gc2VhcmNoIHF1ZXJ5XG4gICAgICA6IG9wdGlvbnNGaWx0ZXIoXG4gICAgICAgICAgb3B0aW9ucy5tYXAoaXRlbSA9PiBpdGVtLmxhYmVsSW5MaXN0IHx8IGl0ZW0ubGFiZWwpLFxuICAgICAgICAgIHNlYXJjaFZhbHVlXG4gICAgICAgICkubWFwKG5hbWUgPT5cbiAgICAgICAgICBvcHRpb25zLmZpbmQoaXRlbSA9PiBpdGVtLmxhYmVsSW5MaXN0ID09PSBuYW1lIHx8IGl0ZW0ubGFiZWwgPT09IG5hbWUpXG4gICAgICAgIClcbiAgfVxuXG4gIGhhbmRsZUNoYW5nZSA9IHNlYXJjaFZhbHVlID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHNlYXJjaFZhbHVlXG4gICAgfSlcbiAgfVxuXG4gIGhhbmRsZVNlbGVjdCA9IGl0ZW0gPT4ge1xuICAgIHRoaXMucHJvcHMub25TZWxlY3QoaXRlbSlcbiAgfVxuXG4gIGFzc2lnblNlYXJjaFJlZiA9IHJlZiA9PiB7XG4gICAgdGhpcy5zZWFyY2hSZWYgPSByZWZcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBvcHRpb25zOiBvcmlnaW5hbE9wdGlvbnMsXG4gICAgICBjbG9zZSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgb25TZWxlY3QsXG4gICAgICBzZWxlY3RlZCxcbiAgICAgIGhhc0ZpbHRlcixcbiAgICAgIG9wdGlvblNpemUsXG4gICAgICByZW5kZXJJdGVtLFxuICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICBvcHRpb25zRmlsdGVyLFxuICAgICAgZGVmYXVsdFNlYXJjaFZhbHVlLFxuICAgICAgLi4ucHJvcHNcbiAgICB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnNlYXJjaChvcmlnaW5hbE9wdGlvbnMpXG4gICAgY29uc3QgbGlzdEhlaWdodCA9IGhlaWdodCAtIChoYXNGaWx0ZXIgPyAzMiA6IDApXG5cbiAgICByZXR1cm4gKFxuICAgICAgPFBhbmVcbiAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgZGlzcGxheT1cImZsZXhcIlxuICAgICAgICBmbGV4RGlyZWN0aW9uPVwiY29sdW1uXCJcbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgPlxuICAgICAgICB7aGFzRmlsdGVyICYmIChcbiAgICAgICAgICA8VGFibGVIZWFkPlxuICAgICAgICAgICAgPFNlYXJjaFRhYmxlSGVhZGVyQ2VsbFxuICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVDaGFuZ2V9XG4gICAgICAgICAgICAgIGlubmVyUmVmPXt0aGlzLmFzc2lnblNlYXJjaFJlZn1cbiAgICAgICAgICAgICAgYm9yZGVyUmlnaHQ9e251bGx9XG4gICAgICAgICAgICAgIGhlaWdodD17MzJ9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvVGFibGVIZWFkPlxuICAgICAgICApfVxuICAgICAgICA8UGFuZSBmbGV4PXsxfT5cbiAgICAgICAgICA8VmlydHVhbExpc3RcbiAgICAgICAgICAgIGhlaWdodD17bGlzdEhlaWdodH1cbiAgICAgICAgICAgIHdpZHRoPVwiMTAwJVwiXG4gICAgICAgICAgICBpdGVtU2l6ZT17b3B0aW9uU2l6ZX1cbiAgICAgICAgICAgIGl0ZW1Db3VudD17b3B0aW9ucy5sZW5ndGh9XG4gICAgICAgICAgICBvdmVyc2NhbkNvdW50PXszfVxuICAgICAgICAgICAgc2Nyb2xsVG9BbGlnbm1lbnQ9XCJhdXRvXCJcbiAgICAgICAgICAgIHJlbmRlckl0ZW09eyh7IGluZGV4LCBzdHlsZSB9KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBvcHRpb25zW2luZGV4XVxuICAgICAgICAgICAgICByZXR1cm4gcmVuZGVySXRlbSh7XG4gICAgICAgICAgICAgICAga2V5OiBpdGVtLnZhbHVlLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBpdGVtLmxhYmVsLFxuICAgICAgICAgICAgICAgIHN0eWxlLFxuICAgICAgICAgICAgICAgIGhlaWdodDogb3B0aW9uU2l6ZSxcbiAgICAgICAgICAgICAgICBvblNlbGVjdDogKCkgPT4gdGhpcy5oYW5kbGVTZWxlY3QoaXRlbSksXG4gICAgICAgICAgICAgICAgaXNTZWxlY3RlZDogdGhpcy5pc1NlbGVjdGVkKGl0ZW0pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9fVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvUGFuZT5cbiAgICAgIDwvUGFuZT5cbiAgICApXG4gIH1cbn1cbiJdfQ==